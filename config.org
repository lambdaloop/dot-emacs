#+TITLE: Emacs Config
#+PROPERTY: header-args :tangle yes

* personal
Who am I?
#+begin_src emacs-lisp
  (setq user-full-name "Pierre Karashchuk"
        user-mail-address "krchtchk@gmail.com")
#+end_src
* startup

This supposedly fixes some problem with loading?
#+begin_src emacs-lisp
  (setq tramp-ssh-controlmaster-options "")
#+end_src

I almost never use the *scratch* buffer. Let's start using the dashboard!
#+begin_src emacs-lisp
  (defun get-random-file (dir)
    (concat (file-name-as-directory dir)
            (string-trim-right
             (shell-command-to-string
              (format "ls %s | shuf | head -1" dir)))))

  (defun update-dashboard-image ()
    (interactive)
    (setq dashboard-startup-banner
          (get-random-file "~/Pictures/wallpapers/chosen/small-emacs"))
    (dashboard-refresh-buffer)
    )

  (use-package dashboard
    :ensure t
    :init
    (progn
      (setq dashboard-items '((recents  . 8)
                              (bookmarks . 8)
                              (agenda . 8)))
      (setq dashboard-startup-banner
            (get-random-file "~/Pictures/wallpapers/chosen/small-emacs")))
    :config
    (progn
      (dashboard-setup-startup-hook)
      (setq initial-buffer-choice (lambda () (get-buffer "*dashboard*")))
      )
    )

  (bind-key "z" 'update-dashboard-image dashboard-mode-map)
#+end_src

Setup the PATH
#+begin_src emacs-lisp
  (when (memq window-system '(mac ns))
    (exec-path-from-shell-initialize))
#+end_src

Setup the load path
#+begin_src emacs-lisp
  (add-to-list 'load-path "~/.emacs.d/lisp")
#+end_src
* secrets
#+BEGIN_SRC emacs-lisp
  (load "~/.emacs.d/secrets.el.gpg")
#+END_SRC
* customize file
Set up the customize file to its own separate file, instead of saving

#+begin_src emacs-lisp
  (setq custom-file (expand-file-name "custom.el" user-emacs-directory))
  (load custom-file)
#+end_src
* package config
#+begin_src emacs-lisp
  (unless (assoc-default "melpa" package-archives)
    (add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/") t))
  ;; (unless (assoc-default "melpa-stable" package-archives)
  ;;   (add-to-list 'package-archives '("melpa-stable" . "http://stable.melpa.org/packages/") t))

  (unless (assoc-default "org" package-archives)
    (add-to-list 'package-archives '("org" . "https://orgmode.org/elpa/") t))
#+end_src
* sane defaults
Copied from [[https://github.com/danielmai/.emacs.d][Daniel Mai]], with some of my own additions
** misc
#+begin_src emacs-lisp

  ;; These functions are useful. Activate them.
  (put 'narrow-to-region 'disabled nil)
  (put 'dired-find-alternate-file 'disabled nil)

  ;; Answering just 'y' or 'n' will do
  (defalias 'yes-or-no-p 'y-or-n-p)

  ;; Keep all backup and auto-save files in one directory
  (setq backup-directory-alist '(("." . "~/tmp/emacs-backups")))
  (setq auto-save-file-name-transforms '((".*" "~/tmp/auto-save-list/" t)))

  ;; save lots of backups
  (setq delete-old-versions -1)
  (setq version-control t)
  (setq vc-make-backup-files t)

  ;; UTF-8 please
  (setq locale-coding-system 'utf-8) ; pretty
  (set-terminal-coding-system 'utf-8) ; pretty
  (set-keyboard-coding-system 'utf-8) ; pretty
  (set-selection-coding-system 'utf-8) ; please
  (prefer-coding-system 'utf-8) ; with sugar on top
  (setq-default indent-tabs-mode nil)
  (set-language-environment "UTF-8")
  (set-default-coding-systems 'utf-8)

  ;; Turn off the blinking cursor
  (blink-cursor-mode -1)

  (setq-default indent-tabs-mode nil)
  (setq-default indicate-empty-lines t)

  ;; Don't count two spaces after a period as the end of a sentence.
  ;; Just one space is needed.
  (setq sentence-end-double-space nil)

  ;; delete the region when typing, just like as we expect nowadays.
  (delete-selection-mode t)

  (show-paren-mode t)

  (column-number-mode t)

  (global-visual-line-mode)
  (diminish 'visual-line-mode)

  (setq uniquify-buffer-name-style 'forward)

  ;; Don't beep at me
  (setq visible-bell nil)

  ;; C-n adds newlines
  (setq-default next-line-add-newlines t)

  ;; Add final newline
  (setq-default require-final-newline t)

  ;; enable electric pair mode everywhere
  (electric-pair-mode +1)

  (diminish 'auto-revert-mode)

  ;; auto indent on enter
  (define-key global-map (kbd "RET") 'newline-and-indent)

  (setq vc-follow-symlinks t) 

#+end_src

** page breaks
Here we make page-break characters look pretty, instead of appearing
as =^L= in Emacs. [[http://ericjmritz.name/2015/08/29/using-page-breaks-in-gnu-emacs/][Here's an informative article called "Using
Page-Breaks in GNU Emacs" by Eric J. M. Ritz.]]

#+begin_src emacs-lisp
  (use-package page-break-lines
    :ensure t)
#+end_src
* elisp functions
#+begin_src emacs-lisp
  (defun jlp/add-to-list-multiple (list to-add)
    "Adds multiple items to LIST.
    Allows for adding a sequence of items to the same list, rather
    than having to call `add-to-list' multiple times."
    (interactive)
    (dolist (item to-add)
      (add-to-list list item)))

  (defun package-reinstall-all-activated-packages ()
    "Refresh and reinstall all activated packages."
    (interactive)
    (package-refresh-contents)
    (dolist (package-name package-activated-list)
      (when (package-installed-p package-name)
        (unless (ignore-errors                   ;some packages may fail to install
                  (package-reinstall package-name))
          (warn "Package %s failed to reinstall" package-name)))))
#+end_src
* appearance
** basic appearance
#+begin_src emacs-lisp
  (setq default-frame-alist '((font-backend . "xft")
                              (font . "Dejavu Sans Mono-9")
                              (vertical-scroll-bars)
                              (menu-bar-lines . 0)
                              (tool-bar-lines . 0)
                              ))

  ;; remove window bar
  (set-frame-position nil 0 -24)
  (tool-bar-mode 0)

  (custom-set-faces
   '(variable-pitch ((t (:height 120 :width normal :family "Libertine")))))

  (setq-default cursor-type 'box)
  (blink-cursor-mode 0)
#+end_src

** theme functions
From [[https://github.com/danielmai/.emacs.d/blob/master/config.org][Daniel Mai]]
#+begin_src emacs-lisp
  (defun switch-theme (theme)
    "Disables any currently active themes and loads THEME."
    ;; This interactive call is taken from `load-theme'
    (interactive
     (list
      (intern (completing-read "Load custom theme: "
                               (mapc 'symbol-name
                                     (custom-available-themes))))))
    (let ((enabled-themes custom-enabled-themes))
      (mapc #'disable-theme custom-enabled-themes)
      (load-theme theme t)))

  (defun disable-active-themes ()
    "Disables any currently active themes listed in `custom-enabled-themes'."
    (interactive)
    (mapc #'disable-theme custom-enabled-themes))
#+end_src

** current theme
#+begin_src emacs-lisp
    ;; (use-package color-theme-sanityinc-tomorrow
    ;;   :config (switch-theme 'sanityinc-tomorrow-night))
    ;; (use-package flatland-theme
    ;;   :config (switch-theme 'flatland))
    ;; (use-package misterioso-theme
    ;;   :config (switch-theme 'misterioso))
    ;; (switch-theme 'misterioso)
  (use-package underwater-theme
   :config (switch-theme 'underwater))
#+end_src
** smart-mode-line
#+begin_src emacs-lisp
  (use-package smart-mode-line
    :config
    (progn
      (setq sml/no-confirm-load-theme t)
      (setq sml/replacer-regexp-list
            '(("^~/Dropbox/org/" ":ORG:")
              ("^~/\\.emacs\\.d/elpa/" ":ELPA:")
              ("^~/\\.emacs\\.d/" ":ED:")
              ("^/sudo:.*:" ":SU:")
              ("^~/Dropbox/" ":DBox:")
              ("^:\\([^:]*\\):Documento?s/" ":\\1/Doc:")
              ("^~/research/neuroecon" ":Hsu:")
              ("^~/research/tuthill" ":Tuthill:")
              ("^~/research/brunton" ":Brunton:")
              ("^~/research/" ":RS:")
              ("^~/cs/projects/" ":CS-PROJ:")
              ("^~/data_analysis/" ":DA:")
              ("^~/desktop_scripts/" ":DSc:")
              ))
      (sml/setup)))


#+end_src
** modeline
#+begin_src emacs-lisp
  (use-package time
    :init (setq display-time-format " %H:%M"
                display-time-24hr-format t
                display-time-default-load-average nil)
    :config
    (display-time-mode 1))

#+end_src
* ido
** enable ido + basic settings
#+begin_src emacs-lisp
  (use-package ido
    :disabled t
    :config
    (progn
      (setq ido-enable-flex-matching t)
      ;; (setq ido-everywhere t)
      (setq ido-use-virtual-buffers t)
      (ido-mode -1)
      (setq ido-use-filename-at-point 'guess)
      (setq ido-use-url-at-point nil)
      (setq ido-file-extensions-order '(".org" ".txt" ".md" ".py" ".r" ".R" ".el"))
      (setq ido-default-buffer-method 'selected-window)))


  (use-package ido-completing-read+
    :disabled t
    :ensure ido
    ;; :config (ido-ubiquitous-mode +1)
    )

  (use-package flx-ido
    :disabled t
    :ensure ido
    :config (progn
              (flx-ido-mode +1)
              ;; disable ido faces to see flx highlights
              (setq ido-use-faces nil)
              )
    )


  (use-package ido-at-point
    :disabled t
    :config (ido-at-point-mode))

#+end_src

** bookmark jump
#+begin_src emacs-lisp
  ;; (defun ido-bookmark-jump (bname)
  ;;   "*Switch to bookmark interactively using `ido'."
  ;;   (interactive (list (ido-completing-read "Bookmark: " (bookmark-all-names) nil t)))
  ;;   (bookmark-jump bname))

  ;; (define-key global-map [remap bookmark-jump] 'ido-bookmark-jump)
#+end_src
* ivy - counsel - swiper
** basic setup
#+begin_src emacs-lisp
  (use-package ivy
    :defer 0.1
    :diminish ivy-mode
    :config
    (progn
      (setq ivy-re-builders-alist
            '((swiper . ivy--regex-plus)
              (ivy-bibtex . ivy--regex-plus)
              (t      . ivy--regex-fuzzy))
            ivy-initial-inputs-alist nil
            ivy-use-virtual-buffers t
            ivy-virtual-abbreviate 'full
            ivy-count-format "%d/%d "
            ivy-height 15
            ivy-wrap t
            )
      (ido-mode -1)
      (ivy-mode +1))
    :bind (
           ;; ("C-s" . counsel-grep)
           ("M-x" . counsel-M-x)
           ("C-x C-f" . counsel-find-file)
           ("M-y" . counsel-yank-pop)
           ("C-c j" . counsel-semantic-or-imenu)
           ("C-c u" . counsel-semantic-or-imenu)
           :map ivy-minibuffer-map
           ("C-m" . ivy-alt-done)
           ("M-RET" . ivy-immediate-done)
           ("C-s" . ivy-next-line)
           ("C-r" . ivy-previous-line)
           ("C-w" . ivy-yank-word)
           :map ivy-switch-buffer-map
           ("C-k" . ivy-switch-buffer-kill)
           :map org-mode-map
           ("C-c j" . counsel-org-goto)
           ("C-c u" . counsel-org-goto)
           ))


#+end_src
** counsel dash
#+begin_src emacs-lisp
  (defun eww-open-other-window (url)
    (split-window-horizontally)
    (other-window 1)
    (eww-browse-url url))

  (use-package counsel-dash
    :config
    (setq counsel-dash-browser-func 'eww-open-other-window
          counsel-dash-common-docsets '("NumPy" "SciPy"))
    :bind ("C-c r" . counsel-dash))
#+end_src
** ivy-rich
#+begin_src emacs-lisp
  (use-package ivy-rich
    :config (progn
              (setq ivy-virtual-abbreviate 'full
                    ivy-rich-switch-buffer-align-virtual-buffer t
                    ivy-rich-path-style 'abbrev
                    ivy-rich-switch-buffer-name-max-length 50)
              (ivy-rich-mode 1)
              ))
#+end_src
** historian
#+BEGIN_SRC emacs-lisp
  (use-package historian)
  (use-package ivy-historian)

  (use-package ivy
    :init
    (historian-mode +1)

    :config
    (ivy-historian-mode +1)
    (setq ivy-historian-recent-boost most-positive-fixnum))
#+END_SRC
* misc packages
Here's a bunch of one-liners for package requires
** helm
#+begin_src emacs-lisp
  (use-package helm
    :config
    (progn
      (setq helm-display-header-line nil)
      (set-face-attribute 'helm-source-header nil
                          :height 0.1)
      (setq helm-autoresize-max-height 30)
      (helm-autoresize-mode 1)
      (setq helm-split-window-in-side-p t)

      (define-key helm-map (kbd "<tab>") 'helm-execute-persistent-action) ; rebind tab to run persistent action
      (define-key helm-map (kbd "C-i") 'helm-execute-persistent-action) ; make TAB work in terminal
      (define-key helm-map (kbd "C-z")  'helm-select-action) ; list actions using C-z
      ))

  (use-package helm-org-rifle
    :bind (("C-c h" . helm-org-rifle)))

#+end_src
** darkroom
#+begin_src emacs-lisp
  (use-package darkroom
    :config (setq darkroom-text-scale-increase 0
                  darkroom-margins 0.27))
#+end_src
** magit
#+begin_src emacs-lisp
  (use-package magit :bind ("C-x g" . magit-status)
    :config (setq magit-completing-read-function
                  'magit-ido-completing-read))

#+end_src
** pdf-tools
#+begin_src emacs-lisp
  (setq pdf-view-use-unicode-ligther nil)

  (use-package pdf-tools
    :config (pdf-tools-install))
#+end_src
** expand-region
#+begin_src emacs-lisp
  (use-package expand-region
    :bind* (("M-." . er/expand-region)))
#+end_src
** ess-site
#+begin_src emacs-lisp
  (use-package ess-site
    :config (progn
              (setq ess-use-ido t)
              (ess-toggle-underscore nil)))

#+end_src
** nyan-mode
#+begin_src emacs-lisp
  (use-package nyan-mode :config (nyan-mode +1))
#+end_src
** avy
#+begin_src emacs-lisp
  (use-package avy
    :config (setq avy-timeout-seconds 0.3
                  avy-keys '(?a ?o ?e ?u ?i ?d ?h ?t ?n))
    :bind* (("s-h" . avy-goto-word-1)
            ))
#+end_src
** switch-window
#+begin_src emacs-lisp
  (use-package switch-window
    :init (progn
            (setq switch-window-threshold 3)
            (setq switch-window-input-style 'minibuffer)
            (setq switch-window-preferred 'ivy)
            (setq switch-window-shortcut-style 'qwerty)
            (setq switch-window-qwerty-shortcuts
                  '("h" "t" "n" "s" "a" "o" "e" "u" "g" "c" "r" "l"))
            )) 
#+end_src
** buffer-move
#+begin_src emacs-lisp

  (use-package buffer-move
    :bind (("S-s-<up>" . buf-move-up)
           ("S-s-<left>" . buf-move-left)
           ("S-s-<right>" . buf-move-right)
           ("S-s-<down>" . buf-move-down)
           )
    )
#+end_src
** sudo-edit
#+begin_src emacs-lisp

  (use-package sudo-edit :ensure t :defer t)
#+end_src
** paradox
#+begin_src emacs-lisp

  (use-package paradox                    ; Better package menu
    :ensure t
    :defer 2
    :config
    (progn
      (setq paradox-execute-asynchronously nil
            paradox-spinner-type 'moon      ; Fancy spinner
            ;; Show all possible counts
            paradox-display-download-count t
            paradox-display-star-count t
            ;; Don't star automatically
            paradox-automatically-star nil
            ;; Hide download button, and wiki packages
            paradox-use-homepage-buttons nil ; Can type v instead
            paradox-hide-wiki-packages t)
      (paradox-enable)))
#+end_src
** async
#+begin_src emacs-lisp

  (use-package async
    :defer t
    :ensure t
    :config
    (setq async-bytecomp-package-mode t
          async-bytecomp-allowed-packages '(all)))

#+end_src
** beacon
#+begin_src emacs-lisp


  (use-package beacon
    :ensure t
    :config
    (beacon-mode 1)
    (setq beacon-push-mark 35
          beacon-blink-when-focused t
          beacon-size 5
          beacon-color "deep sky blue"))

#+end_src
** undo-tree
#+begin_src emacs-lisp

  (use-package undo-tree                  ; Branching undo
    :ensure t
    :init (global-undo-tree-mode)
    :diminish undo-tree-mode)
#+end_src
** zoom
#+begin_src emacs-lisp

  (use-package zoom
    :disabled t
    :init (custom-set-variables
           '(zoom-size '(0.618 . 0.618))
           '(zoom-ignored-major-modes
             '(dired-mode inferior-python-mode))
           '(zoom-ignored-buffer-names '("zoom.el" "init.el"))
           '(zoom-ignored-buffer-name-regexps '("^*Calc"))
           '(zoom-ignore-predicates '((lambda () (> (count-lines (point-min) (point-max)) 20)))))
    :config (zoom-mode +1)
    :bind ("C-x +" . zoom))
#+end_src
** golden-ratio
#+begin_src emacs-lisp

  (use-package golden-ratio
    :disabled t
    :config (golden-ratio-mode)
    :diminish golden-ratio-mode)
#+end_src
** fortune
#+begin_src emacs-lisp

  ;; Fortune path
  (use-package fortune
    :init (setq fortune-dir "/usr/share/fortune"
                fortune-file "/usr/share/fortune/fortunes"))
#+end_src
** yasnippet
#+begin_src emacs-lisp
  (use-package yasnippet
    :config (yas-global-mode)
    :diminish yas-minor-mode)
#+end_src

#+RESULTS:
** crux
crux has a bunch of autoloads, so we use require instead of use-package
#+BEGIN_SRC emacs-lisp
  (require 'crux)
  (crux-with-region-or-buffer indent-region)
  (crux-with-region-or-buffer untabify)
  (crux-with-region-or-line comment-or-uncomment-region)

  (bind-keys
   ("C-x o" . crux-open-with)
   ("M-;" . comment-or-uncomment-region)
   )
#+END_SRC
* system-packages
#+begin_src emacs-lisp
  (require 'system-packages)
  (add-to-list 'system-packages-supported-package-managers
               '(yay .
                     ((default-sudo . nil)
                      (install . "yay -S")
                      (search . "yay -Ss")
                      (uninstall . "yay -Rs")
                      (update . "yay -Syu")
                      (clean-cache . "yay -Sc")
                      (log . "cat /var/log/pacman.log")
                      (get-info . "yay -Qi")
                      (get-info-remote . "yay -Si")
                      (list-files-provided-by . "yay -Ql")
                      (verify-all-packages . "yay -Qkk")
                      (verify-all-dependencies . "yay -Dk")
                      (remove-orphaned . "yay -Rns $(pacman -Qtdq)")
                      (list-installed-packages . "yay -Qe")
                      (list-installed-packages-all . "yay -Q")
                      (list-dependencies-of . "yay -Qi")
                      (noconfirm . "--noconfirm"))))

  (setq system-packages-use-sudo t)
  (setq system-packages-package-manager 'yay)

#+end_src
* keybindings
** ergonomic keys
Based on ergoemacs key bindings, but adjusted for me
I want to have movement using Ctrl+something

#+begin_src emacs-lisp
  (bind-keys
   ("C-x C-x" . pop-to-mark-command)
   ("C-o" . other-window)
   ("C-t" . previous-line)
   ;; ("C-p" . (lambda () (interactive) (message "C-p is disabled. Use C-t to go up.")))
   ("C-p" . transpose-chars)
   ("M-i" . universal-argument)
   ("M-p" . (lambda () (interactive) (execute-kbd-macro (kbd "M-{"))))
   ("M-g" . (lambda () (interactive) (execute-kbd-macro (kbd "M-}"))))
   ("M-[" . (lambda () (interactive) (execute-kbd-macro (kbd "M-{"))))
   ("M-]" . (lambda () (interactive) (execute-kbd-macro (kbd "M-}"))))
   ("C-z" . repeat)
   )

  (bind-keys*
   ("C-." . set-mark-command)
   )

  (define-key key-translation-map (kbd "C-u") (kbd "C-x"))
  (define-key key-translation-map (kbd "M-h") (kbd "C-x C-s"))
  (define-key key-translation-map (kbd "s-g") (kbd "C-g"))

#+end_src

** misc keys
:PROPERTIES:
:ATTACH_DIR_INHERIT: t
:END:
#+begin_src emacs-lisp

  (defun really-kill-this-buffer ()
    "Kill this current buffer."
    (interactive)
    (kill-buffer (current-buffer)))

  (bind-key "C-x k" 'really-kill-this-buffer)

  (defun revert-buffer-no-confirm ()
    "Revert buffer without confirmation."
    (interactive) (revert-buffer t t))
  (bind-key "C-x C-r" 'revert-buffer-no-confirm)

  ;; https://stackoverflow.com/questions/88399/how-do-i-duplicate-a-whole-line-in-emacs
  (defun duplicate-line (arg)
    "Duplicate current line, leaving point in lower line."
    (interactive "*p")

    ;; save the point for undo
    (setq buffer-undo-list (cons (point) buffer-undo-list))

    ;; local variables for start and end of line
    (let ((bol (save-excursion (beginning-of-line) (point)))
          eol)
      (save-excursion

        ;; don't use forward-line for this, because you would have
        ;; to check whether you are at the end of the buffer
        (end-of-line)
        (setq eol (point))

        ;; store the line and disable the recording of undo information
        (let ((line (buffer-substring bol eol))
              (buffer-undo-list t)
              (count arg))
          ;; insert the line arg times
          (while (> count 0)
            (newline)         ;; because there is no newline in 'line'
            (insert line)
            (setq count (1- count)))
          )

        ;; create the undo information
        (setq buffer-undo-list (cons (cons eol (point)) buffer-undo-list)))
      ) ; end-of-let

    ;; put the point in the lowest line and return
    (next-line arg))


  (bind-key  "C-c d" 'duplicate-line)

  (bind-keys ("C-=" . text-scale-increase)
             ("C-\\" . text-scale-decrease))
#+end_src

** god-mode
#+begin_src emacs-lisp
  (use-package god-mode
    :bind (
           ("C-x C-1" . delete-other-windows)
           ("C-x C-2" . split-window-below)
           ("C-x C-3" . split-window-right)
           ("C-x C-0" . delete-window)
           ("C-x C-h" . mark-whole-buffer)
           ("C-c g" . toggle-god-mode)
           :map god-local-mode-map
           ("z" . repeat)
           )
    )


  (setq default-cursor-color  (face-attribute 'cursor :background ))

  (defun hook-update-cursor ()
    (cond ((or (bound-and-true-p god-mode)
               (bound-and-true-p god-global-mode))
           (set-cursor-color "lime green"))
          (t (set-cursor-color default-cursor-color))))

  (add-hook 'buffer-list-update-hook 'hook-update-cursor)

  (add-hook 'god-mode-enabled-hook 'hook-update-cursor)
  (add-hook 'god-mode-disabled-hook 'hook-update-cursor)
  (add-hook 'god-local-mode-hook 'hook-update-cursor)

  (defun toggle-god-mode ()
    (interactive)
    (god-mode-all)
    (hook-update-cursor))


#+end_src
** key chords
#+begin_src emacs-lisp
  (use-package key-chord
    :disabled t
    :config
    (progn
      ;; (fset 'key-chord-define 'my/key-chord-define)
      (setq key-chord-one-key-delay 0.18)
      (setq key-chord-two-keys-delay 0.1)
      (key-chord-mode 1)
      ;; k can be bound too
      ;; (key-chord-define-global "uu"     'undo)
      ;; (key-chord-define-global "jr"     'my/goto-random-char-hydra/my/goto-random-char)
      ;; (key-chord-define-global "kk"     'kill-whole-line)
      ;; (key-chord-define-global "hd"     'avy-goto-char-timer)
      ;; (key-chord-define-global "yy"    'my/window-movement/body)

      (key-chord-define-global "xb"     'ido-switch-buffer)
      (key-chord-define-global "yy"     'switch-window)
      (key-chord-define-global "xf"     'counsel-find-file)
      ;; (key-chord-define-global "jl"     'avy-goto-line)
      ;; (key-chord-define-global "j."     'join-lines/body)
                                          ;(key-chord-define-global "jZ"     'avy-zap-to-char)
      ;; (key-chord-define-global "FF"     'find-file)
      ;; (key-chord-define-global "qq"     'my/quantified-hydra/body)
      ;; (key-chord-define-global "hh"     'my/key-chord-commands/body)
      ;; (key-chord-define-global "xx"     'er/expand-region)
      ;; (key-chord-define-global "  "     'my/insert-space-or-expand)
      (key-chord-define-global "vv" 'toggle-god-mode)
      ;; (key-chord-define-global "JJ"     'my/switch-to-previous-buffe)
      ))
#+END_SRC
** windows
#+begin_src emacs-lisp
  (defun other-window-kill-buffer ()
    "Kill the buffer in the other window"
    (interactive)
    ;; Window selection is used because point goes to a different window
    ;; if more than 2 windows are present
    (let ((win-curr (selected-window))
          (win-other (next-window)))
      (select-window win-other)
      (kill-this-buffer)
      (select-window win-curr)))

  (bind-key "C-c o" 'other-window-kill-buffer)

(defun toggle-window-split ()
  (interactive)
  (if (= (count-windows) 2)
      (let* ((this-win-buffer (window-buffer))
         (next-win-buffer (window-buffer (next-window)))
         (this-win-edges (window-edges (selected-window)))
         (next-win-edges (window-edges (next-window)))
         (this-win-2nd (not (and (<= (car this-win-edges)
                     (car next-win-edges))
                     (<= (cadr this-win-edges)
                     (cadr next-win-edges)))))
         (splitter
          (if (= (car this-win-edges)
             (car (window-edges (next-window))))
          'split-window-horizontally
        'split-window-vertically)))
    (delete-other-windows)
    (let ((first-win (selected-window)))
      (funcall splitter)
      (if this-win-2nd (other-window 1))
      (set-window-buffer (selected-window) this-win-buffer)
      (set-window-buffer (next-window) next-win-buffer)
      (select-window first-win)
      (if this-win-2nd (other-window 1))))))

(bind-key "C-c t" 'toggle-window-split)

#+end_src
** mark region
#+begin_src emacs-lisp
  (require 'expand-region)

  (defun er/mark-line()
    (interactive)
    (back-to-indentation)
    (set-mark (point))
    (move-end-of-line nil)
    (re-search-backward "^\\|[^[:space:]]")
    (when (eq last-command 'er/expand-region)
      (forward-char)))

  (defhydra hydra-mark (:body-pre (call-interactively 'set-mark-command)
                                  :exit t)
    "hydra for mark commands"
    ("SPC" er/expand-region)
    ("P" er/mark-inside-pairs)
    ("Q" er/mark-inside-quotes)
    ("p" er/mark-outside-pairs)
    ("q" er/mark-outside-quotes)
    ("d" er/mark-defun)
    ("c" er/mark-comment)
    ("." er/mark-text-sentence)
    ("h" er/mark-text-paragraph)
    ("w" er/mark-word)
    ("u" er/mark-url)
    ("m" er/mark-email)
    ("s" er/mark-symbol)
    ("l" er/mark-line)
    ("j" (funcall 'set-mark-command t) :exit nil))

  (bind-key* "C-c SPC" 'hydra-mark/body)

#+end_src
* shells
** multi term
#+begin_src emacs-lisp
  (use-package multi-term
    :config
    (progn
      (setq multi-term-program "/usr/bin/zsh")
      (unbind-key "C-u" term-raw-map)
      (unbind-key "C-x" term-raw-map)
      (add-to-list 'term-bind-key-alist '("M-DEL" . term-send-backward-kill-word))
      )
    :bind (; ("C-c M-m" . multi-term)
           :map term-mode-map
           ("M-p" . term-send-up)
           ("M-n" . term-send-down)
           ("C-p" . term-send-up)
           ("C-n" . term-send-down)
           ("M-{" . multi-term-prev)
           ("M-}" . multi-term-next)
           ("M-b" . term-send-backward-word)
           ("M-f" . term-send-forward-word)
           ("C-c C-c" . term-quit-subjob)
           :map term-raw-map
           ("C-o" . other-window)
           ;; ("C-x b" . ido-switch-buffer)
           )
    )



#+end_src
** eshell
*** basic config
#+begin_src emacs-lisp
  (use-package eshell
    :config
    (progn
      (setq ;; eshell-buffer-shorthand t ...  Can't see Bug#19391
       eshell-scroll-to-bottom-on-input 'all
       eshell-error-if-no-glob t
       eshell-hist-ignoredups t
       eshell-save-history-on-exit t
       eshell-prefer-lisp-functions nil
       eshell-destroy-buffer-when-process-dies t
       eshell-history-size 1024
       )
      (add-hook 'eshell-mode-hook
                (lambda ()
                  (jlp/add-to-list-multiple
                   'eshell-visual-commands
                   '("ssh" "tail" "top" "htop" "mosh" "mpsyt" "watch" "ncdu" "cmatrix"))
                  (bind-keys :map eshell-mode-map
                             ("C-t" . eshell-previous-matching-input-from-input)
                             ("C-p" . eshell-previous-matching-input-from-input)
                             ("C-n" . eshell-next-matching-input-from-input)
                             )
                  )))
    )

  ;; default ssh for tramp
  (setq tramp-default-method "ssh")

  ;; sudo?
  (add-to-list 'eshell-modules-list 'eshell-tramp)
  (setq password-cache t) ; enable password caching
  (setq password-cache-expiry 3600) ; for one hour (time in secs)

#+end_src
*** aliases
#+begin_src emacs-lisp
  (use-package eshell
    :init
    (add-hook 'eshell-mode-hook (lambda ()
                                  (eshell/alias "e" "find-file $1")
                                  (eshell/alias "ff" "find-file $1")
                                  (eshell/alias "f" "find-file-other-window $1")
                                  (eshell/alias "fo" "find-file-other-window $1")
                                  (eshell/alias "gd" "magit-diff-unstaged")
                                  (eshell/alias "gds" "magit-diff-staged")
                                  (eshell/alias "d" "dired $1")
                                  (eshell/alias "l" "ls -hA $1")
                                  (eshell/alias "ll" "ls -lhA $1")
                                  (eshell/alias "rs" "rsync -ah --info=progress2 $*")
                                  (eshell/alias "mpc" "/usr/bin/mpc $*")
                                  (eshell/alias "cd" "cd $*; ls")
                                  )))
#+end_src
*** C-d to delete or exit
#+begin_src emacs-lisp
  (use-package eshell
    :config
    (defun ha/eshell-quit-or-delete-char (arg)
      (interactive "p")
      (if (and (eolp) (looking-back eshell-prompt-regexp))
          (progn
            (eshell-life-is-too-much) ; Why not? (eshell/exit)
            ;; (ignore-errors
            ;;   (delete-window)
            ;; )
            )
        (delete-forward-char arg)))
    :init (add-hook 'eshell-mode-hook
                    (lambda ()
                      (bind-keys :map eshell-mode-map
                                 ("C-d" . ha/eshell-quit-or-delete-char)))))
#+end_src
*** eshell-here
#+begin_src emacs-lisp
  (defun eshell-here (split)
    "Opens up a new shell in the directory associated with the
            current buffer's file. The eshell is renamed to match that
            directory to make multiple eshell windows easier."
    (interactive "p")
    (let* ((parent (if (buffer-file-name)
                       (file-name-directory (buffer-file-name))
                     default-directory))
           (height (round (/ (window-total-height) 2.61)))
           (name   (car (last (split-string parent "/" t)))))
      (if split
          (split-window-vertically (- height))
        (split-window-horizontally)
        )
      (other-window 1)
      (eshell "new")
      (rename-buffer (concat "*eshell: " name "*"))
      (insert (concat "ls"))
      (eshell-send-input)))


  (defun eshell-cwd ()
    "Sets the eshell directory to the current buffer"
    (interactive)
    (let ( (fname (buffer-file-name)) )
      (eshell)
      (when fname
        (with-current-buffer "*eshell*"
          (cd (file-name-directory fname))
          (eshell-emit-prompt)
          (insert (concat "ls -A"))
          (eshell-send-input)
          ))))


  ;; (bind-key* "C-'" (lambda () (interactive) (eshell-here t)))
  ;; (bind-key* "C-c C-m" (lambda () (interactive) (eshell-here nil)))

  (bind-key* "C-c M-m" (lambda () (interactive) (eshell "new")))
  ;; (bind-key "S-s-<return>" 'eshell-cwd)

#+end_src
*** better history handling
#+begin_src emacs-lisp
  (defun eshell-next-prompt (n)
    "Move to end of Nth next prompt in the buffer. See `eshell-prompt-regexp'."
    (interactive "p")
    (re-search-forward eshell-prompt-regexp nil t n)
    (when eshell-highlight-prompt
      (while (not (get-text-property (line-beginning-position) 'read-only) )
        (re-search-forward eshell-prompt-regexp nil t n)))
    (eshell-skip-prompt))

  (defun eshell-previous-prompt (n)
    "Move to end of Nth previous prompt in the buffer. See `eshell-prompt-regexp'."
    (interactive "p")
    (backward-char)
    (eshell-next-prompt (- n)))

  (defun eshell-insert-history ()
    "Displays the eshell history to select and insert back into your eshell."
    (interactive)
    (insert (ivy-completing-read "Eshell history: "
                                 (delete-dups
                                  (ring-elements eshell-history-ring)))))

  (add-hook 'eshell-mode-hook (lambda ()
                                (define-key eshell-mode-map (kbd "M-P") 'eshell-previous-prompt)
                                (define-key eshell-mode-map (kbd "M-N") 'eshell-next-prompt)
                                (define-key eshell-mode-map (kbd "M-r") 'eshell-insert-history)))
#+end_src
*** completions
#+begin_src emacs-lisp
  (use-package pcmpl-args)
  (use-package esh-autosuggest
    :hook (eshell-mode . esh-autosuggest-mode)
    ;; If you have use-package-hook-name-suffix set to nil, uncomment and use the
    ;; line below instead:
    ;; :hook (eshell-mode-hook . esh-autosuggest-mode)
    :ensure t)

  (defun setup-eshell-completion ()
    (define-key eshell-mode-map (kbd "<tab>") 'completion-at-point)
    (esh-autosuggest-mode +1)
    (bind-key "C-e"  'company-complete-selection  esh-autosuggest-active-map))

  (add-hook 'eshell-mode-hook #'setup-eshell-completion)

  (use-package fish-completion
    :config
    (progn
      (setq fish-completion-fallback-on-bash-p t)
      (global-fish-completion-mode)))

#+end_src
*** eshell banner intro
#+begin_src emacs-lisp

  (setq happy-words-fname "~/Dropbox/lists/happy_articles.txt")
  (setq happy-faces-fname "~/Dropbox/lists/happy_emoticons.txt")

  (defun get-random-line-file (fname)
    (string-trim-right
     (shell-command-to-string
      (format "shuf %s | head -1" fname))))



  (setq bold-keyword-face
        `(:foreground ,(face-attribute 'font-lock-keyword-face :foreground)
                      :weight bold ))

  (setq bold-constant-face
        `(:foreground ,(face-attribute 'font-lock-constant-face :foreground)
                      :weight bold ))

  (setq bold-default-face
        `(:foreground ,(face-attribute 'default :foreground)
                      :weight bold ))

  (setq bold-function-face
        `(:foreground ,(face-attribute 'font-lock-function-name-face :foreground)
                      :weight bold ))

  (setq banner-eshell-face `(:foreground "sky blue" :weight bold))
  (setq banner-word-face `(:foreground "#9EC400" :weight bold))

  (defun my-eshell-banner-hook ()
    (setq eshell-banner-message
          (format
           "\nWelcome to %s.\nHave a %s day! %s\n\n"
           (propertize "eshell" 'face banner-eshell-face)
           (propertize (get-random-line-file happy-words-fname)
                       'face banner-word-face)
           (get-random-line-file happy-faces-fname)
           ))
    )



  (add-hook 'eshell-banner-load-hook 'my-eshell-banner-hook)


#+end_src
*** eshell prompt
#+begin_src emacs-lisp
  (defun fish-path (path max-len)
    "Return a potentially trimmed-down version of the directory PATH, replacing
  parent directories with their initial characters to try to get the character
  length of PATH (sans directory slashes) down to MAX-LEN."
    (let* ((components (split-string (abbreviate-file-name path) "/"))
           (len (+ (1- (length components))
                   (reduce '+ components :key 'length)))
           (str ""))
      (while (and (> len max-len)
                  (cdr components))
        (setq str (concat str
                          (cond ((= 0 (length (car components))) "/")
                                ((= 1 (length (car components)))
                                 (concat (car components) "/"))
                                (t
                                 (if (string= "."
                                              (string (elt (car components) 0)))
                                     (concat (substring (car components) 0 2)
                                             "/")
                                   (string (elt (car components) 0) ?/)))))
              len (- len (1- (length (car components))))
              components (cdr components)))
      (concat str (reduce (lambda (a b) (concat a "/" b)) components))))

  (setq eshell-path-face
        `(:foreground ,(face-attribute 'font-lock-keyword-face :foreground)
                      :weight normal ))

  (defun my-eshell-prompt-function ()
    (concat
     (propertize (fish-path (eshell/pwd) 20) 'face eshell-path-face)
     (if (= (user-uid) 0) " # " " $ "))
    )
  (setq eshell-highlight-prompt nil)

  (setq eshell-prompt-function 'my-eshell-prompt-function)
#+end_src
*** eshell history
#+BEGIN_SRC emacs-lisp
  (defun eshell-append-history ()
    "Call `eshell-write-history' with the `append' parameter set to `t'."
    (when eshell-history-ring
      (let ((newest-cmd-ring (make-ring 1)))
        (ring-insert newest-cmd-ring (car (ring-elements eshell-history-ring)))
        (let ((eshell-history-ring newest-cmd-ring))
          (eshell-write-history eshell-history-file-name t)))))
  (add-hook 'eshell-pre-command-hook #'eshell-append-history)
  (add-hook 'eshell-mode-hook '(lambda ()
                                 (setq eshell-exit-hook nil)
                                 (setq eshell-save-history-on-exit nil)))
#+END_SRC
*** xterm color
#+BEGIN_SRC emacs-lisp
  (use-package xterm-color 
    :disabled t
    :config (progn 
              (add-hook 'eshell-before-prompt-hook
                        (lambda ()
                          (setq xterm-color-preserve-properties t)))

              (add-to-list 'eshell-preoutput-filter-functions 'xterm-color-filter)
              (setq eshell-output-filter-functions (remove 'eshell-handle-ansi-color eshell-output-filter-functions))
              ))
#+END_SRC
* recentf
#+begin_src emacs-lisp
  ;; (defun ido-recentf-open ()
  ;;   "Use `ido-completing-read' to find a recent file."
  ;;   (interactive)
  ;;   (if (find-file (ido-completing-read "Find recent file: " recentf-list))
  ;;       (message "Opening file...")
  ;;     (message "Aborting")))

  (use-package recentf                    ; Save recently visited files
    :init (recentf-mode)
    :bind (("C-c f" . counsel-recentf))
    :config
    (setq recentf-max-saved-items nil
          recentf-max-menu-items 40
          ;; Cleanup recent files only when Emacs is idle, but not when the mode
          ;; is enabled, because that unnecessarily slows down Emacs. My Emacs
          ;; idles often enough to have the recent files list clean up regularly
          recentf-auto-cleanup 'never ;; disable before we start recentf! If using Tramp a lot.
          recentf-exclude (list "/\\.git/.*\\'" ; Git contents
                                "/elpa/.*\\'" ; Package files
                                "/itsalltext/" ; It's all text temp files
                                )))

  (run-with-timer 0 (* 30 60) 'recentf-save-list)
#+end_src
* dired
#+begin_src emacs-lisp
  (define-key dired-mode-map "i" 'counsel-find-file)
  (define-key dired-mode-map "n" 'dired-next-line)
  (define-key dired-mode-map "h" 'dired-next-line)
  (define-key dired-mode-map "t" 'dired-previous-line)
  (define-key dired-mode-map "o" 'dired-display-file)
  (define-key dired-mode-map "\C-o" 'other-window)
  (define-key dired-mode-map "."
    (lambda ()
      (interactive)
      (find-alternate-file "..")))
  (setq dired-listing-switches "-alh")

#+end_src
* flyspell
#+begin_src emacs-lisp
  (use-package flyspell
    :config (progn
              (add-hook 'text-mode-hook 'flyspell-mode)
              (add-hook 'org-mode-hook 'flyspell-mode)
              (add-hook 'LaTeX-mode-hook 'flyspell-mode)
              ))

  (use-package flyspell-correct
    :ensure flyspell
    :config (progn
              (require 'flyspell-correct-ido)
              (unbind-key "C-M-i" flyspell-mode-map)
              )
    :bind (:map flyspell-mode-map
                ("C-;" . flyspell-correct-previous-word-generic)))

#+end_src

* org mode
** org requires
#+begin_src emacs-lisp
  (require 'org)
  (require 'org-agenda)
#+end_src
** org-archive-subtree-hierarchical
#+begin_src emacs-lisp
  ;; org-archive-subtree-hierarchical.el
  ;; modified from https://lists.gnu.org/archive/html/emacs-orgmode/2014-08/msg00109.html

  ;; In orgmode
  ;; * A
  ;; ** AA
  ;; *** AAA
  ;; ** AB
  ;; *** ABA
  ;; Archiving AA will remove the subtree from the original file and create
  ;; it like that in archive target:

  ;; * AA
  ;; ** AAA

  ;; And this give you
  ;; * A
  ;; ** AA
  ;; *** AAA


  (require 'org-archive)

  (defun org-archive-subtree-hierarchical--line-content-as-string ()
    "Returns the content of the current line as a string"
    (save-excursion
      (beginning-of-line)
      (buffer-substring-no-properties
       (line-beginning-position) (line-end-position))))

  (defun org-archive-subtree-hierarchical--org-child-list ()
    "This function returns all children of a heading as a list. "
    (interactive)
    (save-excursion
      ;; this only works with org-version > 8.0, since in previous
      ;; org-mode versions the function (org-outline-level) returns
      ;; gargabe when the point is not on a heading.
      (if (= (org-outline-level) 0)
          (outline-next-visible-heading 1)
        (org-goto-first-child))
      (let ((child-list (list (org-archive-subtree-hierarchical--line-content-as-string))))
        (while (org-goto-sibling)
          (setq child-list (cons (org-archive-subtree-hierarchical--line-content-as-string) child-list)))
        child-list)))

  (defun org-archive-subtree-hierarchical--org-struct-subtree ()
    "This function returns the tree structure in which a subtree
  belongs as a list."
    (interactive)
    (let ((archive-tree nil))
      (save-excursion
        (while (org-up-heading-safe)
          (let ((heading
                 (buffer-substring-no-properties
                  (line-beginning-position) (line-end-position))))
            (if (eq archive-tree nil)
                (setq archive-tree (list heading))
              (setq archive-tree (cons heading archive-tree))))))
      archive-tree))

  (defun org-archive-subtree-hierarchical ()
    "This function archives a subtree hierarchical"
    (interactive)
    (let ((org-tree (org-archive-subtree-hierarchical--org-struct-subtree))
          (this-buffer (current-buffer))
          (file (abbreviate-file-name
                 (or (buffer-file-name (buffer-base-buffer))
                     (error "No file associated to buffer")))))
      (save-excursion
        (setq location (org-get-local-archive-location)
              afile (org-extract-archive-file location)
              heading (org-extract-archive-heading location)
              infile-p (equal file (abbreviate-file-name (or afile ""))))
        (unless afile
          (error "Invalid `org-archive-location'"))
        (if (> (length afile) 0)
            (setq newfile-p (not (file-exists-p afile))
                  visiting (find-buffer-visiting afile)
                  buffer (or visiting (find-file-noselect afile)))
          (setq buffer (current-buffer)))
        (unless buffer
          (error "Cannot access file \"%s\"" afile))
        (org-cut-subtree)
        (set-buffer buffer)
        (org-mode)
        (goto-char (point-min))
        (while (not (equal org-tree nil))
          (let ((child-list (org-archive-subtree-hierarchical--org-child-list)))
            (if (member (car org-tree) child-list)
                (progn
                  (search-forward (car org-tree) nil t)
                  (setq org-tree (cdr org-tree)))
              (progn
                (goto-char (point-max))
                (newline)
                (org-insert-struct org-tree)
                (setq org-tree nil)))))
        (newline)
        (org-yank)
        (when (not (eq this-buffer buffer))
          (save-buffer))
        (message "Subtree archived %s"
                 (concat "in file: " (abbreviate-file-name afile))))))

  (defun org-insert-struct (struct)
    "TODO"
    (interactive)
    (when struct
      (insert (car struct))
      (newline)
      (org-insert-struct (cdr struct))))

  (defun org-archive-subtree ()
    (org-archive-subtree-hierarchical)
    )
#+end_src

#+RESULTS:
: org-archive-subtree
** org keybindings
Global keybindings
#+begin_src emacs-lisp
  (bind-keys*
   ("C-c a" . org-agenda)
   ("C-c l" . org-store-link)
   ("C-c c" . org-capture)
   )
#+end_src
Local keybindings
#+begin_src emacs-lisp
  (defun org-insert-current-date ()
    (interactive)
    (org-insert-time-stamp (current-time))
    )
  (bind-keys :map org-mode-map
             ("C-c s" . org-archive-subtree-hierarchical)
             ("C-c C-k" . org-cut-subtree)
             ("C-c 3" . org-toggle-inline-images)
             ("C-c i" . org-ref-ivy-insert-cite-link)
             :map org-agenda-mode-map
             ("t" . org-agenda-previous-line)
             ("c" . org-agenda-todo)
             ("r" . org-agenda-schedule)
             ("s" . org-save-all-org-buffers)
             ("d" . org-agenda-deadline)
             :map org-src-mode-map
             ("C-c C-c" . org-edit-src-exit)
             )
#+end_src

** org options
This includes options for source blocks and agenda.
#+begin_src emacs-lisp
  (setq org-src-tab-acts-natively t)
  (setq org-startup-folded t)
  (setq org-agenda-inhibit-startup nil)
  (setq org-startup-indented t)
  (setq org-tags-column -45)
  (setq-default org-tags-column -45)

  (setq org-agenda-start-on-weekday 6) ;; start week on Saturdays
  (setq org-agenda-span 9)
  (setq org-agenda-tags-column -40) ; take advantage of the screen width
  (setq org-agenda-sticky nil)
  (setq org-agenda-use-tag-inheritance t)
  (setq org-agenda-show-log t)
  (setq org-agenda-skip-scheduled-if-done t)
  (setq org-agenda-skip-deadline-if-done t)
  (setq org-agenda-skip-deadline-prewarning-if-scheduled t)
  (setq org-deadline-warning-days 6)
  (setq org-agenda-time-grid
        '((daily today require-timed)
          (800 1000 1200 1400 1600 1800 2000)
          "......" "----------------")
        )
  (setq org-agenda-search-view-always-boolean t)

  ;; setup completion
  (setq org-refile-use-outline-path 'file)
  (setq org-completion-use-ido t)
  (setq org-outline-path-complete-in-steps nil)

  (setq org-cycle-separator-lines 2)

  (setq org-agenda-log-mode-items '(closed clock state))
  (setq org-pretty-entities t)
  (setq org-pretty-entities-include-sub-superscripts nil)
#+end_src

#+RESULTS:

** todo
#+begin_src emacs-lisp
  (setq org-todo-keywords
        '((sequence "TODO(t)" "IN-PROGRESS(i)" "WAITING(w@/!)"
                    "SOMEDAY(s)" "PROJECT(p)"
                    "|" "DONE(d)" "CANCELED(c)")
          (sequence "TO-READ(r@)" "READING(e)" "|" "READ(a)")
          ))

  (setq org-log-done 'time)

  (defun org-summary-todo (n-done n-not-done)
    "Switch entry to DONE when all subentries are done, to TODO otherwise."
    (let (org-log-done org-log-states)   ; turn off logging
      (org-todo (if (= n-not-done 0) "DONE" "TODO"))))


  (add-hook 'org-after-todo-statistics-hook 'org-summary-todo)

#+end_src
** misc
#+begin_src emacs-lisp
  ;; org archives are org files too!
  (add-to-list 'auto-mode-alist '("\\.org_archive\\'" . org-mode))
  (add-to-list 'auto-mode-alist '("\\.journal\\'" . org-mode))

  ;; don't confirm when execute code blocks
  (setq org-confirm-babel-evaluate nil)

  (add-hook 'org-mode-hook
            (lambda () (interactive)
              (org-indent-mode +1)
              (org-overview)
              (diminish 'org-indent-mode)))

  ;; completion for org goto
  (setq org-goto-interface 'outline-path-completion)
  (setq org-outline-path-complete-in-steps nil)
#+end_src

** spelling
#+begin_src emacs-lisp
  (add-to-list 'ispell-skip-region-alist '(":\\(PROPERTIES\\|LOGBOOK\\):" . ":END:"))
  (add-to-list 'ispell-skip-region-alist '("#\\+BEGIN_SRC" . "#\\+END_SRC"))
  (add-to-list 'ispell-skip-region-alist '("#\\+begin_src" . "#\\+end_src"))
  (add-to-list 'ispell-skip-region-alist '("#\\+PROPERTY" . "\n"))
  (add-to-list 'ispell-skip-region-alist '("\\[\\[" . "\\]\\]"))
#+end_src

** load languages
Languages which can be evaluated in Org buffers
#+begin_src emacs-lisp
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((emacs-lisp . t)
     (latex . t)
     (python . t)
     (shell . t)))
#+end_src

** org hooks
#+begin_src emacs-lisp
    (use-package org-zotxt
      :config (add-hook 'org-mode-hook (lambda () (org-zotxt-mode +1)))
      :diminish org-zotxt-mode)

    (use-package org-bullets
      :config (progn
                (add-hook 'org-mode-hook (lambda () (org-bullets-mode 1)))
                (setq org-bullets-bullet-list
                      '( "⚫")
                      ;; '(" ")
                      ;; '("◉" "⚫" "○" "☉" "◎" "◉" "○" "◌" "◎" "●" "⊙" "⊚" "⊛" "∙" "∘")
                      ;; "✸" "◆" "○" "•"
                      ;; ♥ ● ◇ ✚ ✜ ☯ ◆ ♠ ♣ ♦ ☢ ❀ ◆ ◖ ▶ ○
                      )))

#+end_src

#+RESULTS:
: t

** org latex
#+begin_src emacs-lisp
  (fset 'org-latex-subtree-to-pdf
        "\C-c\C-e\C-slp")

  (bind-keys :map org-mode-map
             ;; ("C-c e" . org-latex-subtree-to-pdf)
             ("C-c e" . org-latex-export-to-pdf)
             ("C-c 4" . org-toggle-latex-fragment))
  (plist-put org-format-latex-options :scale 1.25)
  (setq org-latex-pdf-process (list "latexmk -bibtex -pdf %f"))
  (setq org-latex-to-mathml-convert-command nil)
#+end_src

** org download
#+begin_src emacs-lisp
  (use-package org-download
    :config (setq-default org-download-image-dir "./img/"))
#+end_src
** org ref
#+begin_src emacs-lisp
  (use-package ivy-bibtex
    :init (progn
            (setq bibtex-completion-notes-path "~/Dropbox/org/references/article_notes.org")
            (setq bibtex-completion-bibliography '("~/Dropbox/org/references/articles.bib"))
            (setq reftex-default-bibliography bibtex-completion-bibliography)
            (setq bibtex-completion-pdf-field "file")
            (setq bibtex-completion-notes-template-one-file "\n* ${year} - ${title}\n  :PROPERTIES:\n  :Custom_ID: ${=key=}\n  :AUTHOR: ${author}\n  :URL: ${url}\n  :END:\ncite:${=key=}\n")
            )
    :bind* ("C-c b" . ivy-bibtex))
  (use-package org-ref
    :defer 1
    :ensure ivy-bibtex
    :init (progn
            (setq org-ref-bibliography-notes bibtex-completion-notes-path
                  org-ref-default-bibliography bibtex-completion-bibliography
                  org-ref-pdf-directory "~/Dropbox/org/references/pdfs/")

            (setq org-ref-completion-library 'org-ref-ivy-cite)
            (setq org-ref-insert-cite-key "C-c i")

            (defun my/org-ref-notes-function (thekey)
              (bibtex-completion-edit-notes
               (list (car (org-ref-get-bibtex-key-and-file thekey)))))

            (setq org-ref-notes-function 'my/org-ref-notes-function)

            (defun my/org-ref-get-pdf-filename (key)
              "Open the pdf for bibtex key under point if it exists."
              (interactive)
              (let* ((bibtex-completion-bibliography (org-ref-find-bibliography))
                     (pdf-file (car (bibtex-completion-find-pdf key))))
                pdf-file))

            (setq org-ref-get-pdf-filename-function 'my/org-ref-get-pdf-filename)
            )
    )


#+end_src
** org speed keys
#+begin_src emacs-lisp
  (setq org-use-speed-commands
        (lambda () (and (looking-at org-outline-regexp) (looking-back "^\**"))))

  (setq org-speed-commands-user
        '(("t" . (lambda () (interactive)
                   (org-speed-move-safe 'org-previous-visible-heading)))
          ("c" . org-todo)
          ("r" . org-schedule)
          ("d" . org-deadline)
          ("h" . org-cycle)
          ))
#+end_src
** appearance
#+BEGIN_SRC emacs-lisp
  (add-hook 'org-mode-hook (lambda () (progn
    (setq left-margin-width 2)
    (setq right-margin-width 2)
    (set-window-buffer nil (current-buffer))
    (fringe-mode 0))))
#+END_SRC
* latex
** setup
#+begin_src emacs-lisp
  (add-hook 'LaTeX-mode-hook 'visual-line-mode)
  (add-hook 'LaTeX-mode-hook 'flyspell-mode)
  (add-hook 'LaTeX-mode-hook 'LaTeX-math-mode)
  (add-hook 'LaTeX-mode-hook 'TeX-PDF-mode)

  (setq TeX-PDF-mode t)

  (add-hook 'pdf-view-mode-hook 'auto-revert-mode)

  (use-package auctex-latexmk
    :config (progn
              (setq auctex-latexmk-inherit-TeX-PDF-mode t)
              (auctex-latexmk-setup)))


  (require 'tex-buf)

  (defun run-latexmk ()
    (interactive)
    (let ((TeX-save-query nil)
          (TeX-process-asynchronous nil)
          (master-file (TeX-master-file)))
      (TeX-save-document "")
      (TeX-run-TeX "latexmk" "latexmk -pdf" master-file)
      (if (plist-get TeX-error-report-switches (intern master-file))
          (TeX-next-error t)
        (minibuffer-message "latexmk done"))))

  (bind-key "C-c e" 'run-latexmk LaTeX-mode-map)

#+end_src


** org-ref
#+begin_src emacs-lisp
  (defun org-ref-to-latex-citation ()
    (interactive)
    (let ((end (point)))
      (search-backward "cite")
      (insert "\\")
      (search-forward ":")
      (replace-match "{")
      (goto-char end)
      (forward-char)
      (insert "}")
      ))

  (defun org-ref-ivy-insert-cite-latex ()
    (interactive)
    (org-ref-ivy-insert-cite-link)
    (org-ref-to-latex-citation))

  (bind-keys :map LaTeX-mode-map
             ;; ("C-c e" . org-latex-subtree-to-pdf)
             ("C-c i" . org-ref-ivy-insert-cite-latex))


#+end_src
* company mode
#+begin_src emacs-lisp
  (use-package company
    :disabled t
    :defer 2
    :diminish
    :custom
    (company-begin-commands '(self-insert-command))
    (company-idle-delay .5)
    (company-minimum-prefix-length 2)
    (company-show-numbers t)
    (company-tooltip-align-annotations t)
    (company-tooltip-flip-when-above t)
    (global-company-mode nil)
    )

  (use-package company-quickhelp          ; Show help in tooltip
    :disabled t                           ; M-h clashes with mark-paragraph
    :ensure t
    :after company
    :config (company-quickhelp-mode))

  (use-package company-statistics         ; Sort company candidates by statistics
    :ensure t
    :after company
    :config (company-statistics-mode))
#+end_src

* python
** ipython shell
#+begin_src emacs-lisp
  (use-package python
    :config
    (setq python-shell-interpreter "~/.local/bin/ipython3"
          python-shell-interpreter-args "--simple-prompt -i"
          python-shell-completion-native-enable nil))

  (defun clear-shell ()
    (interactive)
    (let ((comint-buffer-maximum-size 0))
      (comint-truncate-buffer)))

#+end_src
** ipython-notebook
#+begin_src emacs-lisp

  (defun bind-ein-keys () 
    (bind-keys :map ein:notebook-mode-map
               ("M-p" . ein:worksheet-goto-prev-input)
               ("M-n" . ein:worksheet-goto-next-input)
               ("M-g" . ein:worksheet-goto-next-input)
               ("C-c p" . ein:worksheet-goto-prev-input)
               ("C-c n" . ein:worksheet-goto-next-input)
               ("<C-return>" . ein:worksheet-execute-cell-and-goto-next)
               ("." . self-insert-command)
               )
    )

  (use-package ein
    :after (progn
             (require 'ein-loaddefs)
             (require 'ein-notebook)
             (require 'ein-subpackages))
    :config 
    (add-hook 'ein:notebook-mode-hook 'bind-ein-keys)
    )




#+end_src
** python company
#+begin_src emacs-lisp
  ;; (defun my/python-mode-hook ()
  ;;   (add-to-list 'company-backends 'company-jedi))

  ;; (add-hook 'python-mode-hook 'my/python-mode-hook)
#+end_src
* matlab
#+begin_src emacs-lisp
  (add-to-list 'auto-mode-alist '("\\.m\\'" . octave-mode))
#+end_src
* elisp
#+BEGIN_SRC emacs-lisp
(defun remove-elc-on-save ()
  "If you're saving an elisp file, likely the .elc is no longer valid."
  (add-hook 'after-save-hook
            (lambda ()
              (if (file-exists-p (concat buffer-file-name "c"))
                  (delete-file (concat buffer-file-name "c"))))
            nil
            t))
  
(add-hook 'emacs-lisp-mode-hook 'remove-elc-on-save)

#+END_SRC
* frontend
** jsx
#+begin_src emacs-lisp
  (add-to-list 'auto-mode-alist '("components\\/.*\\.js\\'" . rjsx-mode))
#+end_src
* beeminder
From https://github.com/mbork/beeminder.el

#+begin_src emacs-lisp
  (use-package beeminder
    :config
    (setq beeminder-username "lambdaloop"
          beeminder-when-the-day-ends 3600 ; 1am
          ))

#+end_src
* exwm
** suggested configuration
#+begin_src emacs-lisp
  ;; Load EXWM.
  (require 'exwm)

  ;; Fix problems with Ido (if you use it).
  (require 'exwm-config)
  ;; (exwm-config-ido)

  ;; Set the initial number of workspaces (they can also be created later).
  (setq exwm-workspace-number 9)

  ;; You can hide the minibuffer and echo area when they're not used, by
  ;; uncommenting the following line.
  ;; (setq exwm-workspace-minibuffer-position 'bottom)

  (setq window-divider-default-right-width 5)
  (window-divider-mode)

  (setq exwm-workspace-show-all-buffers t)
  (setq exwm-layout-show-all-buffers t)

  (setq exwm-input--update-focus-interval 0.1)
#+end_src
** exwm-edit
#+begin_src emacs-lisp
  (use-package exwm-edit)
#+end_src
** renaming buffers to appropriate name
#+begin_src emacs-lisp
  ;; All buffers created in EXWM mode are named "*EXWM*". You may want to
  ;; change it in `exwm-update-class-hook' and `exwm-update-title-hook', which
  ;; are run when a new X window class name or title is available.  Here's
  ;; some advice on this topic:
  ;; + Always use `exwm-workspace-rename-buffer` to avoid naming conflict.
  ;; + For applications with multiple windows (e.g. GIMP), the class names of
                                          ;    all windows are probably the same.  Using window titles for them makes
  ;;   more sense.
  ;; In the following example, we use class names for all windows expect for
  ;; Java applications and GIMP.
  (add-hook 'exwm-update-class-hook
            (lambda ()
              (unless (or (string-prefix-p "sun-awt-X11-" exwm-instance-name)
                          (string= "gimp" exwm-instance-name))
                (exwm-workspace-rename-buffer exwm-class-name))))
  (add-hook 'exwm-update-title-hook
            (lambda ()
              (when (or (not exwm-instance-name)
                        (string-prefix-p "sun-awt-X11-" exwm-instance-name)
                        (string= "gimp" exwm-instance-name))
                (exwm-workspace-rename-buffer exwm-title))))
#+end_src
** set up keybindings
#+begin_src emacs-lisp
  (require 'my-exwm-keys)
#+end_src
** enable exwm
#+begin_src emacs-lisp
  (exwm-enable)
#+end_src
* hippie expand
#+begin_src emacs-lisp
  (bind-key "M-/" 'hippie-expand)

  (setq hippie-expand-try-functions-list
        '(try-complete-file-name-partially
          try-complete-file-name
          try-expand-dabbrev
          try-expand-dabbrev-all-buffers
          try-expand-dabbrev-from-kill
          try-complete-lisp-symbol-partially 
          try-complete-lisp-symbol
          ))
#+end_src
* leim
#+BEGIN_SRC emacs-lisp
  (require 'quail)

  (add-to-list 'quail-keyboard-layout-alist
               `("dvorak" . ,(concat "                              "
                                     "  1!2@3#4$5%6^7&8*9(0)[{]}`~  "
                                     "  '\",<.>pPyYfFgGcCrRlL/?=+    "
                                     "  aAoOeEuUiIdDhHtTnNsS-_\\|    "
                                     "  ;:qQjJkKxXbBmMwWvVzZ        "
                                     "                              ")))

  (quail-set-keyboard-layout "dvorak")
  (setq default-input-method "korean-hangul")

#+END_SRC
* notmuch
#+BEGIN_SRC emacs-lisp
  (setq notmuch-search-oldest-first nil
        message-sendmail-envelope-from 'header
        mail-specify-envelope-from 'header
        mail-envelope-from 'header
        notmuch-show-all-multipart/alternative-parts nil
        ;; mime-edit-pgp-signers '("C84EF897")
        ;; mime-edit-pgp-encrypt-to-self t
        ;; mml2015-encrypt-to-self t
        ;; mml2015-sign-with-sender t
        ;; notmuch-crypto-process-mime t
        message-send-mail-function 'message-send-mail-with-sendmail
        sendmail-program "~/mail/scripts/msmtp-enqueue.sh"
        message-sendmail-f-is-evil nil
        mail-interactive t
        message-kill-buffer-on-exit t
        mail-user-agent 'message-user-agent
        notmuch-always-prompt-for-sender t
        ;; notmuch-fcc-dirs '((".*" . "Defunct/Sent"))
        notmuch-show-indent-messages-width 4
        notmuch-saved-searches '((:name "inbox" :query "tag:inbox" :key "i")
                                 (:name "unread" :query "tag:unread" :key "u")
                                 (:name "flagged" :query "tag:flagged" :key "f")
                                 (:name "sent" :query "tag:sent" :key "t")
                                 (:name "drafts" :query "tag:draft" :key "d")
                                 (:name "all mail" :query "*" :key "a")))
#+END_SRC

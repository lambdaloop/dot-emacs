#+TITLE: Emacs Config
#+PROPERTY: header-args :tangle yes

* personal
Who am I?
#+begin_src emacs-lisp
  (setq user-full-name "Pierre Karashchuk"
        user-mail-address "krchtchk@gmail.com")
#+end_src
* startup

This supposedly fixes some problem with loading?
#+begin_src emacs-lisp
(setq tramp-ssh-controlmaster-options "")
#+end_src

I almost never use the *scratch* buffer. Let's start using the dashboard!
#+begin_src emacs-lisp
  (use-package dashboard
    :ensure t
    :init
    (progn
      (setq dashboard-items '((recents  . 8)
                              (bookmarks . 8)
                              (agenda . 8)))
      (setq dashboard-startup-banner "~/Pictures/wallpapers/chosen/small/772110.png"))
    :config
    (progn
      (dashboard-setup-startup-hook)
      (setq initial-buffer-choice (lambda () (get-buffer "*dashboard*")))
      )
    )
#+end_src

Setup the PATH
#+begin_src emacs-lisp
  (when (memq window-system '(mac ns))
    (exec-path-from-shell-initialize))
#+end_src

Setup the load path
#+begin_src emacs-lisp
  (add-to-list 'load-path "~/.emacs.d/lisp")
#+end_src
* customize file
Set up the customize file to its own separate file, instead of saving

#+begin_src emacs-lisp
  (setq custom-file (expand-file-name "custom.el" user-emacs-directory))
  (load custom-file)
#+end_src
* package config
#+begin_src emacs-lisp
  (unless (assoc-default "melpa" package-archives)
    (add-to-list 'package-archives '("melpa" . "http://melpa.org/packages/") t))
  ;; (unless (assoc-default "melpa-stable" package-archives)
  ;;   (add-to-list 'package-archives '("melpa-stable" . "http://stable.melpa.org/packages/") t))

  (unless (assoc-default "org" package-archives)
    (add-to-list 'package-archives '("org" . "http://orgmode.org/elpa/") t))
#+end_src
* elisp functions
#+begin_src emacs-lisp
  (defun jlp/add-to-list-multiple (list to-add)
    "Adds multiple items to LIST.
  Allows for adding a sequence of items to the same list, rather
  than having to call `add-to-list' multiple times."
    (interactive)
    (dolist (item to-add)
      (add-to-list list item)))

(defun package-reinstall-all-activated-packages ()
  "Refresh and reinstall all activated packages."
  (interactive)
  (package-refresh-contents)
  (dolist (package-name package-activated-list)
    (when (package-installed-p package-name)
      (unless (ignore-errors                   ;some packages may fail to install
                (package-reinstall package-name))
        (warn "Package %s failed to reinstall" package-name)))))
#+end_src
* appearance
** basic appearance
#+begin_src emacs-lisp
  (setq default-frame-alist '((font-backend . "xft")
                              (font . "Dejavu Sans Mono-9")
                              (vertical-scroll-bars)
                              (menu-bar-lines . 0)
                              (tool-bar-lines . 0)
                              ))

  ;; remove window bar
  (set-frame-position nil 0 -24)
  (tool-bar-mode 0)

  (custom-set-faces
   '(variable-pitch ((t (:height 100 :width normal :family "Noto Sans")))))

  (setq-default cursor-type 'box)
  (blink-cursor-mode 0)
#+end_src

** theme functions
From [[https://github.com/danielmai/.emacs.d/blob/master/config.org][Daniel Mai]]
#+begin_src emacs-lisp
  (defun switch-theme (theme)
    "Disables any currently active themes and loads THEME."
    ;; This interactive call is taken from `load-theme'
    (interactive
     (list
      (intern (completing-read "Load custom theme: "
                               (mapc 'symbol-name
                                     (custom-available-themes))))))
    (let ((enabled-themes custom-enabled-themes))
      (mapc #'disable-theme custom-enabled-themes)
      (load-theme theme t)))

  (defun disable-active-themes ()
    "Disables any currently active themes listed in `custom-enabled-themes'."
    (interactive)
    (mapc #'disable-theme custom-enabled-themes))
#+end_src

** current theme
#+begin_src emacs-lisp
  ;; (use-package color-theme-sanityinc-tomorrow
  ;;   :config (switch-theme 'sanityinc-tomorrow-night)) 
  (use-package flatland-theme
    :config (switch-theme 'flatland)) 
#+end_src
** smart-mode-line
#+begin_src emacs-lisp
  (use-package smart-mode-line
    :config
    (progn
      (setq sml/no-confirm-load-theme t)
      (setq sml/replacer-regexp-list
            '(("^~/Dropbox/org/" ":ORG:")
              ("^~/\\.emacs\\.d/elpa/" ":ELPA:")
              ("^~/\\.emacs\\.d/" ":ED:")
              ("^/sudo:.*:" ":SU:")
              ("^~/Dropbox/" ":DBox:")
              ("^:\\([^:]*\\):Documento?s/" ":\\1/Doc:")
              ("^~/research/neuroecon" ":NEcon:")
              ("^~/research/" ":RS:")
              ("^~/cs/projects/" ":CS-PROJ:")
              ("^~/data_analysis/" ":DA:")
              ("^~/desktop_scripts/" ":DSc:")
              ))
      (sml/setup)))


#+end_src
** modeline
#+begin_src emacs-lisp
  (use-package time
    :init (setq display-time-format " %H:%M"
                display-time-24hr-format t
                display-time-default-load-average nil)
    :config
    (display-time-mode 1))

#+end_src
* ido
** enable ido + basic settings
#+begin_src emacs-lisp 
  (use-package ido
    :disabled t
    :config
    (progn
      (setq ido-enable-flex-matching t)
      ;; (setq ido-everywhere t)
      (setq ido-use-virtual-buffers t)
      (ido-mode -1)
      (setq ido-use-filename-at-point 'guess)
      (setq ido-use-url-at-point nil)
      (setq ido-file-extensions-order '(".org" ".txt" ".md" ".py" ".r" ".R" ".el"))
      (setq ido-default-buffer-method 'selected-window)))


  (use-package ido-completing-read+
    :disabled t
    :ensure ido
    ;; :config (ido-ubiquitous-mode +1)
    )

  (use-package flx-ido
    :disabled t
    :ensure ido
    :config (progn
              (flx-ido-mode +1)
              ;; disable ido faces to see flx highlights
              (setq ido-use-faces nil)
              )
    )


  (use-package ido-at-point
    :disabled t
    :config (ido-at-point-mode))

#+end_src

** bookmark jump
#+begin_src emacs-lisp
  ;; (defun ido-bookmark-jump (bname)
  ;;   "*Switch to bookmark interactively using `ido'."
  ;;   (interactive (list (ido-completing-read "Bookmark: " (bookmark-all-names) nil t)))
  ;;   (bookmark-jump bname))

  ;; (define-key global-map [remap bookmark-jump] 'ido-bookmark-jump)
#+end_src
* ivy - counsel - swiper
#+begin_src emacs-lisp
  (use-package ivy
    :diminish ivy-mode
    :config
    (progn  
      (setq ivy-re-builders-alist 
            '((swiper . ivy--regex-plus)
              (t      . ivy--regex-fuzzy))
            ivy-initial-inputs-alist nil
            ivy-use-virtual-buffers t
            ivy-virtual-abbreviate 'full
            ivy-count-format "%d/%d "
            ivy-height 8
            )
      (ido-mode -1)
      (ivy-mode +1))
    :bind (
           ("C-s" . swiper)
           ("M-x" . counsel-M-x)
           ("C-x C-f" . counsel-find-file)
           :map ivy-minibuffer-map
           ("C-m" . ivy-alt-done)
           ("C-s" . ivy-next-line)
           ("C-r" . ivy-previous-line)
           ("C-w" . ivy-yank-word)
           :map ivy-switch-buffer-map
           ("C-k" . ivy-switch-buffer-kill)
           :map org-mode-map
           ("C-c j" . counsel-org-goto)
           ))


#+end_src
** counsel dash
#+begin_src emacs-lisp
  (defun eww-open-other-window (url)  
    (split-window-horizontally) 
    (other-window 1) 
    (eww-browse-url url))

  (use-package counsel-dash 
    :init 
    (setq counsel-dash-browser-func 'eww-open-other-window))
#+end_src

* sane defaults
Copied from [[https://github.com/danielmai/.emacs.d][Daniel Mai]], with some of my own additions
Let's start with some sane defaults, shall we?
Sources for this section include [[https://github.com/magnars/.emacs.d/blob/master/settings/sane-defaults.el][Magnars Sveen]] and [[http://pages.sachachua.com/.emacs.d/Sacha.html][Sacha Chua]].
** misc
#+begin_src emacs-lisp

  ;; These functions are useful. Activate them.
  (put 'narrow-to-region 'disabled nil)
  (put 'dired-find-alternate-file 'disabled nil)

  ;; Answering just 'y' or 'n' will do
  (defalias 'yes-or-no-p 'y-or-n-p)

  ;; Keep all backup and auto-save files in one directory
  (setq backup-directory-alist '(("." . "~/tmp/emacs-backups")))
  (setq auto-save-file-name-transforms '((".*" "~/tmp/auto-save-list/" t)))

  ;; save lots of backups
  (setq delete-old-versions -1)
  (setq version-control t)
  (setq vc-make-backup-files t)

  ;; UTF-8 please
  (setq locale-coding-system 'utf-8) ; pretty
  (set-terminal-coding-system 'utf-8) ; pretty
  (set-keyboard-coding-system 'utf-8) ; pretty
  (set-selection-coding-system 'utf-8) ; please
  (prefer-coding-system 'utf-8) ; with sugar on top
  (setq-default indent-tabs-mode nil)

  ;; Turn off the blinking cursor
  (blink-cursor-mode -1)

  (setq-default indent-tabs-mode nil)
  (setq-default indicate-empty-lines t)

  ;; Don't count two spaces after a period as the end of a sentence.
  ;; Just one space is needed.
  (setq sentence-end-double-space nil)

  ;; delete the region when typing, just like as we expect nowadays.
  (delete-selection-mode t)

  (show-paren-mode t)

  (column-number-mode t)

  (global-visual-line-mode)
  (diminish 'visual-line-mode)

  (setq uniquify-buffer-name-style 'forward)

  ;; Don't beep at me
  (setq visible-bell nil)

  ;; C-n adds newlines
  (setq-default next-line-add-newlines t)

  ;; Add final newline
  (setq-default require-final-newline t)

  ;; enable electric pair mode everywhere
  (electric-pair-mode +1)

  (diminish 'auto-revert-mode)

  #+end_src

** page breaks
Here we make page-break characters look pretty, instead of appearing
as =^L= in Emacs. [[http://ericjmritz.name/2015/08/29/using-page-breaks-in-gnu-emacs/][Here's an informative article called "Using
Page-Breaks in GNU Emacs" by Eric J. M. Ritz.]]

#+begin_src emacs-lisp
  (use-package page-break-lines
    :ensure t)
#+end_src
* misc packages
Here's a bunch of one-liners for package requires
#+begin_src emacs-lisp

    (use-package helm
      :config
      (progn 
        (setq helm-display-header-line nil)
        (set-face-attribute 'helm-source-header nil
                            :height 0.1)
        (setq helm-autoresize-max-height 30)
        (helm-autoresize-mode 1)
        (setq helm-split-window-in-side-p t)

        (define-key helm-map (kbd "<tab>") 'helm-execute-persistent-action) ; rebind tab to run persistent action
        (define-key helm-map (kbd "C-i") 'helm-execute-persistent-action) ; make TAB work in terminal
        (define-key helm-map (kbd "C-z")  'helm-select-action) ; list actions using C-z
        ))

    (use-package darkroom)

    (use-package magit :bind ("C-x g" . magit-status)
      :config (setq magit-completing-read-function
                    'magit-ido-completing-read))

    (setq pdf-view-use-unicode-ligther nil)

    (use-package "pdf-tools"
      :config (pdf-tools-install))

    (use-package expand-region
      :bind* (("M-." . er/expand-region)))

    (use-package ess-site
      :config (progn
                (setq ess-use-ido t)
                (ess-toggle-underscore nil)))

    (use-package nyan-mode :config (nyan-mode +1))

    (use-package avy
      :config (setq avy-timeout-seconds 0.3
                    avy-keys '(?a ?o ?e ?u ?i ?d ?h ?t ?n))
      :bind* (("C-c h" . avy-goto-word-1)
              ("s-h" . avy-goto-word-1)
              ))


    (use-package switch-window
      :init (progn
              (setq switch-window-threshold 3)
              (setq switch-window-shortcut-style 'qwerty)
              (setq switch-window-qwerty-shortcuts
                    '("h" "t" "n" "s" "a" "o" "e" "u" "g" "c" "r" "l"))
              )
      :bind (("C-x o" . switch-window)))


    (use-package sudo-edit :ensure t :defer t)

    (use-package paradox                    ; Better package menu
      :ensure t
      :defer 2 
      :config
      (progn
        (setq paradox-execute-asynchronously nil
              paradox-spinner-type 'moon      ; Fancy spinner
              ;; Show all possible counts
              paradox-display-download-count t
              paradox-display-star-count t
              ;; Don't star automatically
              paradox-automatically-star nil
              ;; Hide download button, and wiki packages
              paradox-use-homepage-buttons nil ; Can type v instead
              paradox-hide-wiki-packages t)
        (paradox-enable)))

    (use-package async
      :defer t
      :ensure t
      :config
      (setq async-bytecomp-package-mode t
            async-bytecomp-allowed-packages '(all)))



    (use-package beacon
      :ensure t
      :config
      (beacon-mode 1)
      (setq beacon-push-mark 35
            beacon-blink-when-focused t 
            beacon-size 5
            beacon-color "deep sky blue"))


    (use-package undo-tree                  ; Branching undo
      :ensure t
      :init (global-undo-tree-mode)
      :diminish undo-tree-mode)

    (use-package zoom 
      :disabled t
      :init (custom-set-variables
             '(zoom-size '(0.618 . 0.618))
             '(zoom-ignored-major-modes 
               '(dired-mode inferior-python-mode))
             '(zoom-ignored-buffer-names '("zoom.el" "init.el"))
             '(zoom-ignored-buffer-name-regexps '("^*Calc"))
             '(zoom-ignore-predicates '((lambda () (> (count-lines (point-min) (point-max)) 20)))))
      :config (zoom-mode +1)
      :bind ("C-x +" . zoom))

    (use-package golden-ratio
      :config (golden-ratio-mode)
      :diminish golden-ratio-mode)

    ;; Fortune path
    (use-package fortune 
      :init (setq fortune-dir "/usr/share/fortune"
                  fortune-file "/usr/share/fortune/fortunes"))

#+end_src

#+RESULTS:
* system-packages
#+begin_src emacs-lisp
(require 'system-packages)
(add-to-list 'system-packages-supported-package-managers
             '(yay .
                      ((default-sudo . nil)
                       (install . "yay -S")
                       (search . "yay -Ss")
                       (uninstall . "yay -Rs")
                       (update . "yay -Syu")
                       (clean-cache . "yay -Sc")
                       (log . "cat /var/log/pacman.log")
                       (get-info . "yay -Qi")
                       (get-info-remote . "yay -Si")
                       (list-files-provided-by . "yay -Ql")
                       (verify-all-packages . "yay -Qkk")
                       (verify-all-dependencies . "yay -Dk")
                       (remove-orphaned . "yay -Rns $(pacman -Qtdq)")
                       (list-installed-packages . "yay -Qe")
                       (list-installed-packages-all . "yay -Q")
                       (list-dependencies-of . "yay -Qi")
                       (noconfirm . "--noconfirm"))))

(setq system-packages-use-sudo t)
(setq system-packages-package-manager 'yay)

#+end_src
* keybindings
** ergonomic keys
Based on ergoemacs key bindings, but adjusted for me
I want to have movement using Ctrl+something

#+begin_src emacs-lisp
  (bind-keys
   ("C-o" . other-window)
   ("C-t" . previous-line)
   ;; ("C-p" . (lambda () (interactive) (message "C-p is disabled. Use C-t to go up.")))
   ("C-p" . transpose-chars)
   ("M-i" . universal-argument)
   ("M-p" . (lambda () (interactive) (execute-kbd-macro (kbd "M-{"))))
   ("M-g" . (lambda () (interactive) (execute-kbd-macro (kbd "M-}"))))
   ("M-[" . (lambda () (interactive) (execute-kbd-macro (kbd "M-{"))))
   ("M-]" . (lambda () (interactive) (execute-kbd-macro (kbd "M-}"))))
   )

  (bind-keys*
   ("C-." . set-mark-command)
   ("C-c r" . ido-bookmark-jump)
   )

  (define-key key-translation-map (kbd "C-u") (kbd "C-x"))
  (define-key key-translation-map (kbd "M-h") (kbd "C-x C-s"))
  (define-key key-translation-map (kbd "s-g") (kbd "C-g"))

#+end_src

** misc keys
#+begin_src emacs-lisp

  (defun really-kill-this-buffer ()
    "Kill this current buffer."
    (interactive)
    (kill-buffer (current-buffer)))

  (bind-key "C-x k" 'really-kill-this-buffer)

  (defun revert-buffer-no-confirm ()
    "Revert buffer without confirmation."
    (interactive) (revert-buffer t t))
  (bind-key "C-x C-r" 'revert-buffer-no-confirm)
#+end_src

** god-mode
#+begin_src emacs-lisp
  (use-package god-mode
    :bind (
           ("C-x C-1" . delete-other-windows)
           ("C-x C-2" . split-window-below)
           ("C-x C-3" . split-window-right)
           ("C-x C-0" . delete-window)
           ("C-x C-h" . mark-whole-buffer)
           :map god-local-mode-map
           ("z" . repeat)
           )
    )


  (setq default-cursor-color  (face-attribute 'cursor :background ))

  (defun hook-update-cursor ()
    (cond ((or (bound-and-true-p god-mode)
               (bound-and-true-p god-global-mode))
           (set-cursor-color "lime green"))
          (t (set-cursor-color default-cursor-color))))

  (add-hook 'buffer-list-update-hook 'hook-update-cursor)

  (add-hook 'god-mode-enabled-hook 'hook-update-cursor)
  (add-hook 'god-mode-disabled-hook 'hook-update-cursor)
  (add-hook 'god-local-mode-hook 'hook-update-cursor)

  (defun toggle-god-mode ()
    (interactive)
    (god-mode-all)
    (hook-update-cursor))


#+end_src
** key chords
#+begin_src emacs-lisp
  (use-package key-chord
    :config
    (progn
      ;; (fset 'key-chord-define 'my/key-chord-define)
      (setq key-chord-one-key-delay 0.18)
      (setq key-chord-two-keys-delay 0.1)
      (key-chord-mode 1)
      ;; k can be bound too
      ;; (key-chord-define-global "uu"     'undo)
      ;; (key-chord-define-global "jr"     'my/goto-random-char-hydra/my/goto-random-char)
      ;; (key-chord-define-global "kk"     'kill-whole-line)
      ;; (key-chord-define-global "hd"     'avy-goto-char-timer)
      ;; (key-chord-define-global "yy"    'my/window-movement/body)

      (key-chord-define-global "xb"     'ido-switch-buffer)
      (key-chord-define-global "yy"     'switch-window)
      (key-chord-define-global "xf"     'counsel-find-file)
      ;; (key-chord-define-global "jl"     'avy-goto-line)
      ;; (key-chord-define-global "j."     'join-lines/body)
                                          ;(key-chord-define-global "jZ"     'avy-zap-to-char)
      ;; (key-chord-define-global "FF"     'find-file)
      ;; (key-chord-define-global "qq"     'my/quantified-hydra/body)
      ;; (key-chord-define-global "hh"     'my/key-chord-commands/body)
      ;; (key-chord-define-global "xx"     'er/expand-region)
      ;; (key-chord-define-global "  "     'my/insert-space-or-expand)
      (key-chord-define-global "vv" 'toggle-god-mode)
      ;; (key-chord-define-global "JJ"     'my/switch-to-previous-buffe)
      )) 

#+END_SRC
** windows
#+begin_src emacs-lisp
  (defun other-window-kill-buffer ()
    "Kill the buffer in the other window"
    (interactive)
    ;; Window selection is used because point goes to a different window
    ;; if more than 2 windows are present
    (let ((win-curr (selected-window))
          (win-other (next-window)))
      (select-window win-other)
      (kill-this-buffer)
      (select-window win-curr)))

  (bind-key "C-c o" 'other-window-kill-buffer)

#+end_src
** hippie expand
#+begin_src emacs-lisp
  (bind-key "M-/" 'hippie-expand)
  (setq hippie-expand-try-functions-list
        '(try-complete-file-name-partially
          try-complete-file-name
          try-expand-dabbrev
          try-expand-dabbrev-all-buffers
          try-expand-dabbrev-from-kill))
#+end_src
** mark region
#+begin_src emacs-lisp
  (require 'expand-region)

  (defhydra hydra-mark (:body-pre (call-interactively 'set-mark-command)
                                  :exit t)
    "hydra for mark commands"
    ("SPC" er/expand-region)
    ("P" er/mark-inside-pairs)
    ("Q" er/mark-inside-quotes)
    ("p" er/mark-outside-pairs)
    ("q" er/mark-outside-quotes)
    ("d" er/mark-defun)
    ("c" er/mark-comment)
    ("." er/mark-text-sentence)
    ("h" er/mark-text-paragraph)
    ("w" er/mark-word)
    ("u" er/mark-url)
    ("m" er/mark-email)
    ("s" er/mark-symbol)
    ("j" (funcall 'set-mark-command t) :exit nil))

  (bind-key* "C-c SPC" 'hydra-mark/body)

#+end_src
* shells
** multi term
#+begin_src emacs-lisp
  (use-package multi-term
    :disabled t
    :config
    (progn
      (setq multi-term-program "/usr/bin/zsh")
      (unbind-key "C-u" term-raw-map)
      (unbind-key "C-x" term-raw-map)
      (add-to-list 'term-bind-key-alist '("M-DEL" . term-send-backward-kill-word))
      )
    :bind (; ("C-c M-m" . multi-term)
           :map term-mode-map
           ("M-p" . term-send-up)
           ("M-n" . term-send-down)
           ("C-p" . term-send-up)
           ("C-n" . term-send-down)
           ("M-{" . multi-term-prev)
           ("M-}" . multi-term-next)
           ("M-b" . term-send-backward-word)
           ("M-f" . term-send-forward-word)
           :map term-raw-map
           ("C-o" . other-window)
           ;; ("C-x b" . ido-switch-buffer)
           )
    )



#+end_src
** eshell
*** basic config
#+begin_src emacs-lisp
  (use-package eshell
    :init
    (progn
      (setq ;; eshell-buffer-shorthand t ...  Can't see Bug#19391
       eshell-scroll-to-bottom-on-input 'all
       eshell-error-if-no-glob t
       eshell-hist-ignoredups t
       eshell-save-history-on-exit t
       eshell-prefer-lisp-functions nil
       eshell-destroy-buffer-when-process-dies t)
      (add-hook 'eshell-mode-hook
                (lambda ()
                  (jlp/add-to-list-multiple
                   'eshell-visual-commands
                   '("ssh" "tail" "top" "htop" "mosh" "mpsyt"))
                  )))
    )

  ;; default ssh for tramp
  (setq tramp-default-method "ssh")


#+end_src
*** aliases
#+begin_src emacs-lisp
  (use-package eshell
    :init
    (add-hook 'eshell-mode-hook (lambda ()
                                  (eshell/alias "e" "find-file $1")
                                  (eshell/alias "ff" "find-file $1")
                                  (eshell/alias "fo" "find-file-other-window $1")
                                  (eshell/alias "gd" "magit-diff-unstaged")
                                  (eshell/alias "gds" "magit-diff-staged")
                                  (eshell/alias "d" "dired $1")
                                  (eshell/alias "l" "ls -hA $1")
                                  (eshell/alias "ll" "ls -lhA $1")
                                  (eshell/alias "rs" "rsync -ah --info=progress2 $1 $2")
                                  (eshell/alias "mpc" "/usr/bin/mpc $*")
                                  (eshell/alias "cd" "cd $*; ls")
                                  )))
#+end_src
*** C-d to delete or exit
#+begin_src emacs-lisp
  (use-package eshell
    :config
    (defun ha/eshell-quit-or-delete-char (arg)
      (interactive "p")
      (if (and (eolp) (looking-back eshell-prompt-regexp))
          (progn
            (eshell-life-is-too-much) ; Why not? (eshell/exit)
            ;; (ignore-errors
            ;;   (delete-window)
            ;; )
            )
        (delete-forward-char arg)))
    :init
    (add-hook 'eshell-mode-hook
              (lambda ()
                (bind-keys :map eshell-mode-map
                           ("C-d" . ha/eshell-quit-or-delete-char)))))
#+end_src
*** eshell-here
#+begin_src emacs-lisp
  (defun eshell-here (split)
    "Opens up a new shell in the directory associated with the
            current buffer's file. The eshell is renamed to match that
            directory to make multiple eshell windows easier."
    (interactive "p")
    (let* ((parent (if (buffer-file-name)
                       (file-name-directory (buffer-file-name))
                     default-directory))
           (height (round (/ (window-total-height) 2.61)))
           (name   (car (last (split-string parent "/" t)))))
      (if split
          (split-window-vertically (- height))
        (split-window-horizontally)
        )
      (other-window 1)
      (eshell "new")
      (rename-buffer (concat "*eshell: " name "*"))
      (insert (concat "ls"))
      (eshell-send-input)))


  (defun eshell-cwd ()
    "Sets the eshell directory to the current buffer"
    (interactive)
    (let ( (fname (buffer-file-name)) )
      (eshell)
      (when fname 
        (with-current-buffer "*eshell*"
          (cd (file-name-directory fname))
          (eshell-emit-prompt)
          (insert (concat "ls -A"))
          (eshell-send-input)
          ))))


  ;; (bind-key* "C-'" (lambda () (interactive) (eshell-here t)))
  ;; (bind-key* "C-c C-m" (lambda () (interactive) (eshell-here nil)))

  (bind-key* "C-c M-m" (lambda () (interactive) (eshell "new")))
  ;; (bind-key "S-s-<return>" 'eshell-cwd)

#+end_src
*** better history handling
#+begin_src emacs-lisp
  (defun eshell-next-prompt (n)
    "Move to end of Nth next prompt in the buffer. See `eshell-prompt-regexp'."
    (interactive "p")
    (re-search-forward eshell-prompt-regexp nil t n)
    (when eshell-highlight-prompt
      (while (not (get-text-property (line-beginning-position) 'read-only) )
        (re-search-forward eshell-prompt-regexp nil t n)))
    (eshell-skip-prompt))

  (defun eshell-previous-prompt (n)
    "Move to end of Nth previous prompt in the buffer. See `eshell-prompt-regexp'."
    (interactive "p")
    (backward-char)
    (eshell-next-prompt (- n)))

  (defun eshell-insert-history ()
    "Displays the eshell history to select and insert back into your eshell."
    (interactive)
    (insert (ido-completing-read "Eshell history: "
                                 (delete-dups
                                  (ring-elements eshell-history-ring)))))

  (add-hook 'eshell-mode-hook (lambda ()
                                (define-key eshell-mode-map (kbd "M-P") 'eshell-previous-prompt)
                                (define-key eshell-mode-map (kbd "M-N") 'eshell-next-prompt)
                                (define-key eshell-mode-map (kbd "M-r") 'eshell-insert-history)))
#+end_src
*** completions
#+begin_src emacs-lisp
  (use-package pcmpl-args)
  (use-package esh-autosuggest
    :hook (eshell-mode . esh-autosuggest-mode)
    ;; If you have use-package-hook-name-suffix set to nil, uncomment and use the
    ;; line below instead:
    ;; :hook (eshell-mode-hook . esh-autosuggest-mode)
    :ensure t)

  (defun setup-eshell-completion ()
    (define-key eshell-mode-map (kbd "<tab>") 'completion-at-point)
    (esh-autosuggest-mode +1)
    (bind-key "C-e"  'company-complete-selection  esh-autosuggest-active-map))

  (add-hook 'eshell-mode-hook #'setup-eshell-completion)

  (use-package fish-completion
    :config
    (progn 
      (setq fish-completion-fallback-on-bash-p t)
      (global-fish-completion-mode)))

#+end_src
*** eshell banner intro
#+begin_src emacs-lisp

  (setq happy-words-fname "~/Dropbox/lists/happy_articles.txt")
  (setq happy-faces-fname "~/Dropbox/lists/happy_emoticons.txt")

  (defun get-random-line-file (fname)
    (string-trim-right
     (shell-command-to-string
      (format "shuf %s | head -1" fname))))



  (setq bold-keyword-face
        `(:foreground ,(face-attribute 'font-lock-keyword-face :foreground)
                      :weight bold ))

  (setq bold-constant-face
        `(:foreground ,(face-attribute 'font-lock-constant-face :foreground)
                      :weight bold ))

  (setq bold-default-face
        `(:foreground ,(face-attribute 'default :foreground)
                      :weight bold ))

  (setq bold-function-face
        `(:foreground ,(face-attribute 'font-lock-function-name-face :foreground)
                      :weight bold ))

  (defun my-eshell-banner-hook ()
    (setq eshell-banner-message
          (format
           "\nWelcome to %s.\nHave a %s day! %s\n\n"
           (propertize "eshell" 'face bold-constant-face)
           (propertize (get-random-line-file happy-words-fname)
                       'face bold-function-face)
           (get-random-line-file happy-faces-fname)
           ))
    )



  (add-hook 'eshell-banner-load-hook 'my-eshell-banner-hook)


#+end_src
*** eshell prompt
#+begin_src emacs-lisp
  (defun fish-path (path max-len)
    "Return a potentially trimmed-down version of the directory PATH, replacing
  parent directories with their initial characters to try to get the character
  length of PATH (sans directory slashes) down to MAX-LEN."
    (let* ((components (split-string (abbreviate-file-name path) "/"))
           (len (+ (1- (length components))
                   (reduce '+ components :key 'length)))
           (str ""))
      (while (and (> len max-len)
                  (cdr components))
        (setq str (concat str
                          (cond ((= 0 (length (car components))) "/")
                                ((= 1 (length (car components)))
                                 (concat (car components) "/"))
                                (t
                                 (if (string= "."
                                              (string (elt (car components) 0)))
                                     (concat (substring (car components) 0 2)
                                             "/")
                                   (string (elt (car components) 0) ?/)))))
              len (- len (1- (length (car components))))
              components (cdr components)))
      (concat str (reduce (lambda (a b) (concat a "/" b)) components))))

  (setq eshell-path-face
        `(:foreground ,(face-attribute 'font-lock-keyword-face :foreground)
                      :weight normal ))

  (defun my-eshell-prompt-function ()
    (concat
     (propertize (fish-path (eshell/pwd) 20) 'face eshell-path-face)
     (if (= (user-uid) 0) " # " " $ "))
    )
  (setq eshell-highlight-prompt nil)

  (setq eshell-prompt-function 'my-eshell-prompt-function)
#+end_src
* recentf
#+begin_src emacs-lisp
  (defun ido-recentf-open ()
    "Use `ido-completing-read' to find a recent file."
    (interactive)
    (if (find-file (ido-completing-read "Find recent file: " recentf-list))
        (message "Opening file...")
      (message "Aborting")))

  (use-package recentf                    ; Save recently visited files
    :init (recentf-mode)
    :bind (("C-c f" . ido-recentf-open))
    :config
    (setq recentf-max-saved-items 200
          recentf-max-menu-items 15
          ;; Cleanup recent files only when Emacs is idle, but not when the mode
          ;; is enabled, because that unnecessarily slows down Emacs. My Emacs
          ;; idles often enough to have the recent files list clean up regularly
          recentf-auto-cleanup 'never ;; disable before we start recentf! If using Tramp a lot.
          recentf-exclude (list "/\\.git/.*\\'" ; Git contents
                                "/elpa/.*\\'" ; Package files
                                "/itsalltext/" ; It's all text temp files
                                )))
#+end_src
* dired
#+begin_src emacs-lisp
  (define-key dired-mode-map "i" 'counsel-find-file)
  (define-key dired-mode-map "n" 'dired-next-line)
  (define-key dired-mode-map "h" 'dired-next-line)
  (define-key dired-mode-map "t" 'dired-previous-line)
  (define-key dired-mode-map "\C-o" 'other-window)
  (define-key dired-mode-map "."
    (lambda ()
      (interactive)
      (find-alternate-file "..")))
  (setq dired-listing-switches "-alh")

#+end_src
* flyspell
#+begin_src emacs-lisp
  (use-package flyspell
    :config (progn
              (add-hook 'text-mode-hook 'flyspell-mode)
              (add-hook 'org-mode-hook 'flyspell-mode)
              (add-hook 'LaTeX-mode-hook 'flyspell-mode)
              ))

  (use-package flyspell-correct
    :ensure flyspell
    :config (progn
              (require 'flyspell-correct-ido)
              (unbind-key "C-M-i" flyspell-mode-map)
              )
    :bind (:map flyspell-mode-map
                ("C-;" . flyspell-correct-previous-word-generic)))

#+end_src

* org mode
** org requires
#+begin_src emacs-lisp
  (require 'org)
  (require 'org-agenda)
#+end_src
** org-archive-subtree-hierarchical
#+begin_src emacs-lisp
  ;; org-archive-subtree-hierarchical.el
  ;; modified from https://lists.gnu.org/archive/html/emacs-orgmode/2014-08/msg00109.html

  ;; In orgmode
  ;; * A
  ;; ** AA
  ;; *** AAA
  ;; ** AB
  ;; *** ABA
  ;; Archiving AA will remove the subtree from the original file and create
  ;; it like that in archive target:

  ;; * AA
  ;; ** AAA

  ;; And this give you
  ;; * A
  ;; ** AA
  ;; *** AAA


  (require 'org-archive)

  (defun org-archive-subtree-hierarchical--line-content-as-string ()
    "Returns the content of the current line as a string"
    (save-excursion
      (beginning-of-line)
      (buffer-substring-no-properties
       (line-beginning-position) (line-end-position))))

  (defun org-archive-subtree-hierarchical--org-child-list ()
    "This function returns all children of a heading as a list. "
    (interactive)
    (save-excursion
      ;; this only works with org-version > 8.0, since in previous
      ;; org-mode versions the function (org-outline-level) returns
      ;; gargabe when the point is not on a heading.
      (if (= (org-outline-level) 0)
          (outline-next-visible-heading 1)
        (org-goto-first-child))
      (let ((child-list (list (org-archive-subtree-hierarchical--line-content-as-string))))
        (while (org-goto-sibling)
          (setq child-list (cons (org-archive-subtree-hierarchical--line-content-as-string) child-list)))
        child-list)))

  (defun org-archive-subtree-hierarchical--org-struct-subtree ()
    "This function returns the tree structure in which a subtree
  belongs as a list."
    (interactive)
    (let ((archive-tree nil))
      (save-excursion
        (while (org-up-heading-safe)
          (let ((heading
                 (buffer-substring-no-properties
                  (line-beginning-position) (line-end-position))))
            (if (eq archive-tree nil)
                (setq archive-tree (list heading))
              (setq archive-tree (cons heading archive-tree))))))
      archive-tree))

  (defun org-archive-subtree-hierarchical ()
    "This function archives a subtree hierarchical"
    (interactive)
    (let ((org-tree (org-archive-subtree-hierarchical--org-struct-subtree))
          (this-buffer (current-buffer))
          (file (abbreviate-file-name
                 (or (buffer-file-name (buffer-base-buffer))
                     (error "No file associated to buffer")))))
      (save-excursion
        (setq location (org-get-local-archive-location)
              afile (org-extract-archive-file location)
              heading (org-extract-archive-heading location)
              infile-p (equal file (abbreviate-file-name (or afile ""))))
        (unless afile
          (error "Invalid `org-archive-location'"))
        (if (> (length afile) 0)
            (setq newfile-p (not (file-exists-p afile))
                  visiting (find-buffer-visiting afile)
                  buffer (or visiting (find-file-noselect afile)))
          (setq buffer (current-buffer)))
        (unless buffer
          (error "Cannot access file \"%s\"" afile))
        (org-cut-subtree)
        (set-buffer buffer)
        (org-mode)
        (goto-char (point-min))
        (while (not (equal org-tree nil))
          (let ((child-list (org-archive-subtree-hierarchical--org-child-list)))
            (if (member (car org-tree) child-list)
                (progn
                  (search-forward (car org-tree) nil t)
                  (setq org-tree (cdr org-tree)))
              (progn
                (goto-char (point-max))
                (newline)
                (org-insert-struct org-tree)
                (setq org-tree nil)))))
        (newline)
        (org-yank)
        (when (not (eq this-buffer buffer))
          (save-buffer))
        (message "Subtree archived %s"
                 (concat "in file: " (abbreviate-file-name afile))))))

  (defun org-insert-struct (struct)
    "TODO"
    (interactive)
    (when struct
      (insert (car struct))
      (newline)
      (org-insert-struct (cdr struct))))

  (defun org-archive-subtree ()
    (org-archive-subtree-hierarchical)
    )
#+end_src

#+RESULTS:
: org-archive-subtree
** org keybindings
Global keybindings
#+begin_src emacs-lisp
  (bind-keys*
   ("C-c a" . org-agenda)
   ("C-c l" . org-store-link)
   ("C-c c" . org-capture)
   )
#+end_src
Local keybindings
#+begin_src emacs-lisp
  (defun org-insert-current-date ()
    (interactive)
    (org-insert-time-stamp (current-time))
    )
  (bind-keys :map org-mode-map
             ("C-c s" . org-archive-subtree-hierarchical)
             ("C-c C-k" . org-cut-subtree)
             ("C-c 3" . org-toggle-inline-images)
             ("C-c i" . org-ref-ivy-insert-cite-link)
             :map org-agenda-mode-map
             ("t" . org-agenda-previous-line)
             ("c" . org-agenda-todo)
             ("r" . org-agenda-schedule)
             ("s" . org-save-all-org-buffers)
             ("d" . org-agenda-deadline)
             :map org-src-mode-map
             ("C-c C-c" . org-edit-src-exit)
             )
#+end_src

** org options
This includes options for source blocks and agenda.
#+begin_src emacs-lisp
  (setq org-src-tab-acts-natively t)
  (setq org-startup-folded t)
  (setq org-agenda-inhibit-startup nil)
  (setq org-startup-indented t)
  (setq org-tags-column -45)
  (setq-default org-tags-column -45)

  (setq org-agenda-start-on-weekday 6) ;; start week on Saturdays
  (setq org-agenda-span 9)
  (setq org-agenda-tags-column -40) ; take advantage of the screen width
  (setq org-agenda-sticky nil)
  (setq org-agenda-use-tag-inheritance t)
  (setq org-agenda-show-log t)
  (setq org-agenda-skip-scheduled-if-done t)
  (setq org-agenda-skip-deadline-if-done t)
  (setq org-agenda-skip-deadline-prewarning-if-scheduled t)
  (setq org-deadline-warning-days 6)
  (setq org-agenda-time-grid
        '((daily today require-timed)
          (800 1000 1200 1400 1600 1800 2000)
          "......" "----------------")
        )
  (setq org-agenda-search-view-always-boolean t)

  ;; setup completion
  (setq org-refile-use-outline-path 'file)
  (setq org-completion-use-ido t)
  (setq org-outline-path-complete-in-steps nil)

  (setq org-cycle-separator-lines 2)
#+end_src

#+RESULTS:

** todo
#+begin_src emacs-lisp
  (setq org-todo-keywords
        '((sequence "TODO(t)" "IN-PROGRESS(i)" "WAITING(w@/!)"
                    "SOMEDAY(s)" "PROJECT(p)"
                    "|" "DONE(d!)" "CANCELED(c!)")
          (sequence "TO-READ(r@)" "READING(e)" "|" "READ(a)")
          ))

(defun org-summary-todo (n-done n-not-done)
  "Switch entry to DONE when all subentries are done, to TODO otherwise."
  (let (org-log-done org-log-states)   ; turn off logging
    (org-todo (if (= n-not-done 0) "DONE" "TODO"))))

(add-hook 'org-after-todo-statistics-hook 'org-summary-todo)
#+end_src
** misc
#+begin_src emacs-lisp
  ;; org archives are org files too!
  (add-to-list 'auto-mode-alist '("\\.org_archive\\'" . org-mode))
  (add-to-list 'auto-mode-alist '("\\.journal\\'" . org-mode))

  ;; don't confirm when execute code blocks
  (setq org-confirm-babel-evaluate nil)

  (add-hook 'org-mode-hook
            (lambda () (interactive) 
              (org-indent-mode +1)
              (org-overview)))
  (diminish 'org-indent-mode)

  ;; completion for org goto
  ;; (setq org-goto-interface 'outline-path-completion)
  ;; (setq org-outline-path-complete-in-steps nil)
#+end_src

** spelling
#+begin_src emacs-lisp
  (add-to-list 'ispell-skip-region-alist '(":\\(PROPERTIES\\|LOGBOOK\\):" . ":END:"))
  (add-to-list 'ispell-skip-region-alist '("#\\+BEGIN_SRC" . "#\\+END_SRC"))
  (add-to-list 'ispell-skip-region-alist '("#\\+begin_src" . "#\\+end_src"))
  (add-to-list 'ispell-skip-region-alist '("#\\+PROPERTY" . "\n"))
  (add-to-list 'ispell-skip-region-alist '("\\[\\[" . "\\]\\]"))
#+end_src

** load languages
Languages which can be evaluated in Org buffers
#+begin_src emacs-lisp
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((emacs-lisp . t)
     (latex . t)
     (python . t)
     (shell . t)))
#+end_src

** org hooks
#+begin_src emacs-lisp
  (use-package org-zotxt
    :config (add-hook 'org-mode-hook (lambda () (org-zotxt-mode +1)))
    :diminish org-zotxt-mode)

  (use-package org-bullets
    :config (progn
              (add-hook 'org-mode-hook (lambda () (org-bullets-mode 1)))
              (setq org-bullets-bullet-list
                    '("◉" "⚫" "✸" "◆" "○" "•"
                      ;; ♥ ● ◇ ✚ ✜ ☯ ◆ ♠ ♣ ♦ ☢ ❀ ◆ ◖ ▶ ○
                      ))))

#+end_src

** org latex
#+begin_src emacs-lisp
  (fset 'org-latex-subtree-to-pdf
        "\C-c\C-e\C-slp")

  (bind-keys :map org-mode-map
             ;; ("C-c e" . org-latex-subtree-to-pdf)
             ("C-c e" . org-latex-export-to-pdf)
             ("C-c 4" . org-toggle-latex-fragment))
  (plist-put org-format-latex-options :scale 1.25)
  (setq org-latex-pdf-process (list "latexmk -bibtex -pdf %f"))
  (setq org-latex-to-mathml-convert-command nil)
#+end_src

** org download
#+begin_src emacs-lisp
  (use-package org-download
    :config (setq-default org-download-image-dir "./img/"))
#+end_src
** org ref
#+begin_src emacs-lisp
  (use-package ivy-bibtex
    :init (progn
            (setq bibtex-completion-notes-path "~/Dropbox/org/references/article_notes.org")
            (setq bibtex-completion-bibliography '("~/Dropbox/org/references/articles.bib"))
            (setq reftex-default-bibliography bibtex-completion-bibliography)
            (setq bibtex-completion-pdf-field "file")
            (setq bibtex-completion-notes-template-one-file "\n* ${year} - ${title}\n  :PROPERTIES:\n  :Custom_ID: ${=key=}\n  :AUTHOR: ${author}\n  :URL: ${url}\n  :END:\ncite:${=key=}\n")
            )
    :bind* ("C-c b" . ivy-bibtex))
  (use-package org-ref
    :defer 1
    :ensure ivy-bibtex
    :init (progn
            (setq org-ref-bibliography-notes bibtex-completion-notes-path
                  org-ref-default-bibliography bibtex-completion-bibliography
                  org-ref-pdf-directory "~/Dropbox/org/references/pdfs/")

            (setq org-ref-completion-library 'org-ref-ivy-cite)
            (setq org-ref-insert-cite-key "C-c i")

            (defun my/org-ref-notes-function (thekey)
              (bibtex-completion-edit-notes
               (list (car (org-ref-get-bibtex-key-and-file thekey)))))

            (setq org-ref-notes-function 'my/org-ref-notes-function)

            (defun my/org-ref-get-pdf-filename (key)
              "Open the pdf for bibtex key under point if it exists."
              (interactive)
              (let* ((bibtex-completion-bibliography (org-ref-find-bibliography))
                     (pdf-file (car (bibtex-completion-find-pdf key))))
                pdf-file))

            (setq org-ref-get-pdf-filename-function 'my/org-ref-get-pdf-filename)
            )
    )


#+end_src
** org speed keys
#+begin_src emacs-lisp
    (setq org-use-speed-commands
          (lambda () (and (looking-at org-outline-regexp) (looking-back "^\**"))))

    (setq org-speed-commands-user
          '(("t" . (lambda () (interactive) 
                     (org-speed-move-safe 'org-previous-visible-heading)))
          ("T" . org-todo)
  ))
#+end_src
* latex
#+begin_src emacs-lisp
  (add-hook 'LaTeX-mode-hook 'visual-line-mode)
  (add-hook 'LaTeX-mode-hook 'flyspell-mode)
  (add-hook 'LaTeX-mode-hook 'LaTeX-math-mode)
  (add-hook 'LaTeX-mode-hook 'TeX-PDF-mode)

  (setq TeX-PDF-mode t)

  (add-hook 'pdf-view-mode-hook 'auto-revert-mode)

  (use-package auctex-latexmk
    :config (auctex-latexmk-setup))

  (defun org-ref-to-latex-citation ()
    (interactive)
    (let ((end (point)))
      (search-backward "cite")
      (insert "\\")
      (search-forward ":")
      (replace-match "{")
      (goto-char end)
      (forward-char)
      (insert "}")
      ))

  (defun org-ref-ivy-insert-cite-latex ()
    (interactive)
    (org-ref-ivy-insert-cite-link)
    (org-ref-to-latex-citation))

  (bind-keys :map LaTeX-mode-map
             ;; ("C-c e" . org-latex-subtree-to-pdf)
             ("C-c i" . org-ref-ivy-insert-cite-latex))


#+end_src
* company mode
#+begin_src emacs-lisp
  (use-package company
    :disabled t
    :defer 2
    :diminish
    :custom
    (company-begin-commands '(self-insert-command))
    (company-idle-delay .5)
    (company-minimum-prefix-length 2)
    (company-show-numbers t)
    (company-tooltip-align-annotations t)
    (company-tooltip-flip-when-above t)
    (global-company-mode t))

    (use-package company-quickhelp          ; Show help in tooltip
      :disabled t                           ; M-h clashes with mark-paragraph
      :ensure t
      :after company
      :config (company-quickhelp-mode))

    (use-package company-statistics         ; Sort company candidates by statistics
      :ensure t
      :after company
    :config (company-statistics-mode))
#+end_src

* python
** ipython shell
#+begin_src emacs-lisp
  (use-package python
    :config
    (setq python-shell-interpreter "~/.local/bin/ipython3"
          python-shell-interpreter-args "--simple-prompt -i"
          python-shell-completion-native-enable nil))

  (defun clear-shell ()
    (interactive)
    (let ((comint-buffer-maximum-size 0))
      (comint-truncate-buffer)))

#+end_src
** ipython-notebook
#+begin_src emacs-lisp
  (use-package ein
    ;; :after (progn
    ;;           (require 'ein-loaddefs)
    ;;           (require 'ein-notebook)
    ;;           (require 'ein-subpackages))
    :bind (:map ein:notebook-mode-map
                ("M-p" . ein:worksheet-goto-prev-input)
                ("M-n" . ein:worksheet-goto-next-input)
                ("M-g" . ein:worksheet-goto-next-input)
                )
    )


#+end_src
** python company
#+begin_src emacs-lisp
  ;; (defun my/python-mode-hook ()
  ;;   (add-to-list 'company-backends 'company-jedi))

  ;; (add-hook 'python-mode-hook 'my/python-mode-hook)
#+end_src
* matlab
#+begin_src emacs-lisp
  (add-to-list 'auto-mode-alist '("\\.m\\'" . octave-mode))
#+end_src
* frontend
** jsx
#+begin_src emacs-lisp
  (add-to-list 'auto-mode-alist '("components\\/.*\\.js\\'" . rjsx-mode))
#+end_src
* beeminder
From https://github.com/mbork/beeminder.el

#+begin_src emacs-lisp
  (use-package beeminder
    :config
    (setq beeminder-username "lambdaloop"
          beeminder-auth-token "sky318dYcKu1_7YeczPB"
          beeminder-when-the-day-ends 3600 ; 1am
          ))

#+end_src
* exwm
** suggested configuration
#+begin_src emacs-lisp
    ;; Load EXWM.
    (require 'exwm)

    ;; Fix problems with Ido (if you use it).
    (require 'exwm-config)
    ;; (exwm-config-ido)

    ;; Set the initial number of workspaces (they can also be created later).
    (setq exwm-workspace-number 9)

    ;; You can hide the minibuffer and echo area when they're not used, by
    ;; uncommenting the following line.
    ;; (setq exwm-workspace-minibuffer-position 'bottom)

    (setq window-divider-default-right-width 5)
    (window-divider-mode)

    (setq exwm-workspace-show-all-buffers t)
    (setq exwm-layout-show-all-buffers t)

  (setq exwm-input--update-focus-interval 0.1)
#+end_src
** exwm-edit
#+begin_src emacs-lisp
(use-package exwm-edit)
#+end_src
** renaming buffers to appropriate name
#+begin_src emacs-lisp
  ;; All buffers created in EXWM mode are named "*EXWM*". You may want to
  ;; change it in `exwm-update-class-hook' and `exwm-update-title-hook', which
  ;; are run when a new X window class name or title is available.  Here's
  ;; some advice on this topic:
  ;; + Always use `exwm-workspace-rename-buffer` to avoid naming conflict.
  ;; + For applications with multiple windows (e.g. GIMP), the class names of
                                          ;    all windows are probably the same.  Using window titles for them makes
  ;;   more sense.
  ;; In the following example, we use class names for all windows expect for
  ;; Java applications and GIMP.
  (add-hook 'exwm-update-class-hook
            (lambda ()
              (unless (or (string-prefix-p "sun-awt-X11-" exwm-instance-name)
                          (string= "gimp" exwm-instance-name))
                (exwm-workspace-rename-buffer exwm-class-name))))
  (add-hook 'exwm-update-title-hook
            (lambda ()
              (when (or (not exwm-instance-name)
                        (string-prefix-p "sun-awt-X11-" exwm-instance-name)
                        (string= "gimp" exwm-instance-name))
                (exwm-workspace-rename-buffer exwm-title))))
#+end_src
** set up keybindings
#+begin_src emacs-lisp
(require 'my-exwm-keys)
#+end_src
** enable exwm
#+begin_src emacs-lisp
(exwm-enable)
#+end_src
